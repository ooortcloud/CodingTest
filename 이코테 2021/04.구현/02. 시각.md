# 문제 정보

정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다.

- 00시 00분 03초
- 00시 13분 30초

반면 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각이다.

- 00시 02분 55초
- 01시 27분 45초

### 입력

- 첫째 줄에 정수 N이 입력된다. (0이상 23이하)

### 출력

- 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다.

### 예제 입력

```python
5
```

### 예제 출력

```python
11475
```

# 풀이

### 교재 풀이

```python
n = int(input())

count = 0
for i in range(n+1):
    for j in range(60):
        for k in range(60):
            # 문자열로 비교하는 것이 더 간단함
            if '3' in str(i) + str(j) + str(k):
                count += 1

print(count)
```
모든 경우의 수롤 전부 계산했다. 어차피 하루를 초로 세면 86400 개의 경우의 수밖에 없기 때문에, 완전 탐색 방식으로 전부 검사가 가능한 수준이다.

### 내 풀이

```python
n = int(input("n을 입력"))

# 시간에 3이 포함된 경우 모든 분 초를 카운트.
# 분에 3이 포함된 경우 모든 초를 카운트.

cnt = 0
for hour in range(n+1):
    if '3' in str(hour):
        cnt = cnt + 60 * 60
        continue
    
    for min in range(60):

        if '3' in str(min):
            cnt = cnt + 60
            continue
        
        for sec in range(60):
            if '3' in str(sec):
                cnt = cnt + 1

print(cnt)
```

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class MainClass {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		
		// 시간에 3이 들어가면 모든 분초를 카운트
		// 분에 3이 들어가면 모든 초를 카운트
		int cnt = 0;
		for(int hour = 0; hour <= n; hour++) {
			
			if(String.valueOf(hour).contains("3")) {
				cnt += 60*60;
				continue;
			}
			
			for(int min = 0; min < 60; min++) {
				
				if(String.valueOf(min).contains("3")) {
					cnt += 60;
					continue;
				}
				
				for(int sec=0; sec<60; sec++) {
					if(String.valueOf(sec).contains("3")) {
						cnt++;
					}
				}
			}
		}
		
		System.out.println(cnt);
	}
}
```

하지만 나는 조금이라도 더 효율적으로 연산했으면 해서, 충분히 예상할 수 있는 범위 내에서는 예측 가능한 경우의 수를 더해주는 1회 연산 이후 아예 다음으로 넘어가는 식의 프로그래밍을 했다.