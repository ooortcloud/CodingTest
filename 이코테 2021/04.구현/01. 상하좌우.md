# 문제 정보

여행가 A는 $N*N$ 크기의 정사각형 공간 위에 서 있다. 이 공간은 $1*1$ 크기의 정사각형으로 나누어져 있다. 가장 왼쪽 위의 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 지도 상에서 x축은 아래로 내려갈수록 증가하며 y축은 오른쪽으로 이동할수록 증가한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다. 우리 앞에는 여행가 A가 이동할 계획이 적한 계획서가 놓여 있다.

계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있다. 각 문자의 의미는 다음과 같다.

- L : 왼쪽 한 칸 이동
- R : 오른쪽 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동

이때 여행가 A가 $N*N$ 크기의 정사각형 공간을 벗어나는 움직임은 무시된다. 예를 들어 (1, 1)의 위치에서 L 혹은 U를 만나면 해당 문자는 무시한다. 

계획서가 주어졌을 때, 여행가 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 공간의 크기를 나타내는 N이 주어진다. (1 이상 100 이하)
- 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다. (이동 횟수는 1 이상 100 이하)

### 출력

- 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백으로 구분하여 출력한다.

### 예제 입력

```python
5
R R R U D D
```

### 예제 출력

```python
3 4
```

# 풀이

이 문제는 이동 횟수에 정비례하여 연산 횟수가 증가하므로, 시간복잡도는  O(N)이다. 100만번의 이동 명령이 있어도 넉넉하게 풀리는 문제라는 뜻.

이 문제 유형은 어떤 대상에게 일련의 명령을 차례대로 시키는 '시뮬레이션' 유형에 해당한다.

### 교재 풀이

```python
n = int(input())
x,y = 1, 1
planList = input().split()

dx = [0,0,-1,1]
dy = [-1,1,0,0]
commandType = ['L', 'R', 'U', 'D']

for plan in planList:  
    for i in range(len(commandType)):
        if plan == commandType[i]:
            nx = x + dx[i]
            ny = y + dy[i]

    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
    
    x, y = nx, ny

print(x,y)
```

### 나의 풀이

```python
n = map(int, input("n을 입력").split())
moveList = list(input("이동 경로를 입력").split())

# 초기 위치 세팅
x, y = 1, 1

moveDic = {'L':(0,-1), 'R':(0,1), 'U':(-1,0), 'D':(1,0)}
for move in moveList:
    # directory를 사용하여 switch문 구현
    moveX, moveY = moveDic.get(move)

    if not ((x==1 and moveX == -1) or (x==n and moveX == 1)):
        x = x + moveX
    if not ((y==1 and moveY == -1) or (y==n and moveY == 1)):
        y = y + moveY

print(x, y)
```

dictionary 라이브러리를 사용해서 손쉽게 구현이 가능함.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class MainClass {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		// 초기 위치 설정
		int x = 1;
		int y = 1;
		// 이동 컨트롤러 설정 (상, 하, 좌, 우)
		int[] controlX = {-1, 1, 0, 0};
		int[] controlY = {0, 0, -1, 1};
		String[] moveTypes = {"U", "D", "L", "R"}; 
		
		while(st.hasMoreTokens()) {
			int nextX = 0;
			int nextY = 0;
			
			// switch문이 아닌 for문을 사용한 index 기반 조회
			String nextToken = st.nextToken();  // 반복문 안에 넣으면 토큰이 불필요하게 계속 소모됨
			for(int i = 0; i <= 3; i++) {
				if(nextToken.equals(moveTypes[i])) {
					nextX = x + controlX[i];
					nextY = y + controlY[i];
				}
			}

			// 범위를 넘어서면 이 명령은 반영하지 않음
			if ( nextX < 1 || nextX > n || nextY < 1 || nextY > n) {
				continue;
			} 
			// 범위 내에서만 명령 반영
			else {
				x = nextX;
				y = nextY;
			}
		}
		System.out.println(x+" "+y);
	}
}
```
Java의 Map 라이브러리를 사용해도 앞선 풀이처럼 풀 수 있을 거라고 생각함.