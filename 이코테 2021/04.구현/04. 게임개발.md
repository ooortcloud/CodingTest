# 게임 개발_py

## 문제 정보

현민이는 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다. 캐릭터가 있는 장소는 1*1 크기의 정사각형으로 이뤄진 N*M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다. 캐릭터는 동서남북 중 한 곳을 바라본다.

맵의 각 칸은 (A, B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다. 캐릭터의 움직임을 설정하기 위해 정해 놓은 매뉴얼은 이러하다.

1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다.
2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다. 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.
3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.

현민이는 위 과정을 반복적으로 수행하면서 캐릭터의 움직임에 이상이 있는지 테스트하려고 한다. 매뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오.

### 문제 요약

매뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오.

### 입력

- 첫째 줄에 맵의 세로 크기 N과 가로 크기 M을 공백으로 구분하여 입력한다. (각각 3 이상 50 이하)
- 둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (A, B)와 바라보는 방향 d가 각각 서로 공백으로 구분하여 주어진다. 방향 d의 값으로는 다음과 같이 4가지가 존재한다.
    - 0: 북쪽
    - 1: 동쪽
    - 2: 남쪽
    - 3: 서쪽
- 섯째 줄부터 맵이 육지인지 바다인지에 대한 정보가 주어진다. N개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로, 각 줄의 데이터는 서쪽부터 동쪽 순서대로 주어진다. 맵의 외곽은 항상 바다로 되어 있다.
    - 0: 육지
    - 1: 바다
- 처음에 게임 캐릭터가 위치한 칸의 상태는 항상 육지이다.

### 출력

- 첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력한다.

### 예제 입력 1

```python
4 4
1 1 0
1 1 1 1
1 0 0 1
1 1 0 1
1 1 1 1
```

### 예제 출력 1

```python
3
```

## 문제의 의도

- 주어진 문제 상황을 파이썬 문법을 활용하여 해결할 수 있는가?

### 아이디어

- 바라보는 방향의 방향 벡터를 딕셔너리 자료구조를 활용하여 필요할 때마다 호출할 수 있도록 해보자.
- 무한반복문 안에서 사면이 갇힐 때까지 계속 반복시키자. 이전 상태로 돌아가면서 길을 찾을 필요는 없으므로 재귀 형태의 함수를 구현할 필요는 없다.

### 풀이

- 내 풀이

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().rstrip().split())  # 세로 크기, 가로 크기
a, b, d = map(int, input().rstrip().split())  # 캐릭터 위치 (A, B), 바라보는 방향
mapList = list()
for _ in range(n):
    mapList.append(list(map(int, input().rstrip().split())))

# directionMap = {0:(0, -1), 1:(1,0), 2:(0, 1), 3:(-1, 0)}  바라보는 방향 쪽 방향 벡터 (x,y). 참고로 (0,0)은 가장 왼쪽 & 가장 위의 좌표.
leftTurnedDirectionMap = {0:(-1, 0), 1:(0, -1), 2:(1, 0), 3:(0, 1)}  # 바라보는 방향의 왼쪽 방향 벡터 (x,y)
afterTurnedMap = {0:3, 1:0, 2:1, 3:2}  # 방향을 바꾼 후에 바뀐 바라보는 방향
checkedList = list()  # 방문 체크 리스트

cnt = 1  # 시작 위치도 방문 칸으로 취급
tempCount=0
while True:
    # 더 이상 전진할 곳이 없는 경우
    if tempCount == 4:
        # 후진을 시도
        nextA = a - leftTurnedDirectionMap.get(d)[0] 
        nextB = b - leftTurnedDirectionMap.get(d)[1]
        if mapList[nextB][nextA] == 0 and ((nextA, nextB) not in checkedList):
            checkedList.append((a, b))
            a, b = nextA, nextB
            cnt += 1
            tempCount = 0
            continue
        else:
            break

    nextA = a + leftTurnedDirectionMap.get(d)[0] 
    nextB = b + leftTurnedDirectionMap.get(d)[1]
    d = afterTurnedMap.get(d)

    # 왼쪽이 가보지 않은 육지인 경우 왼쪽으로 전진
    if mapList[nextB][nextA] == 0 and ((nextA, nextB) not in checkedList):
        checkedList.append((a, b))
        a, b = nextA, nextB
        cnt += 1
        tempCount = 0
        
    # 왼쪽이 바다이거나 가봤던 육지인 경우 왼쪽으로 회전하기만 함
    else:
        tempCount+=1

print(cnt)
```

- 교재 풀이

```python
n, m = map(int, input().split())

d = [[0]*m for _ in range(n)]  # 방문 좌표 저장 리스트 생성
x, y, direction = map(int, input().split())
d[x][y] = 1  # 시작 좌표 방문 처리

# 실제 맵 정보 저장
array = []
for i in range(n):
    array.append(list(map(int, input().split())))

dx = [-1, 0, 1, 0]  # 좌우 이동 방향 정의
dy = [0, 1, 0, -1]  # 상하 이동 방향 정의

# 왼쪽 회전 도우미 메소드
def turnLeft():
    global direction
    direction -= 1
    if direction == -1:
        direction = 3

cnt = 1
turnTime = 0
while True:
    turnLeft()
    nx = x + dx[direction]
    ny = y + dy[direction]

    # 바라보는 지역이 이전에 방문했던 지역이 아닌 육지인 경우 전진
    if d[nx][ny] == 0 and array[nx][ny] == 0:
        d[nx][ny]=1
        x = nx
        y = ny
        cnt += 1
        turnTime = 0
        continue

    else:
        turnTime += 1

    # 네 방향 모두 전진할 수 없는 경우
    if turnTime == 4:
        nx = x - dx[direction]
        ny = y - dy[direction]
        if array[nx][ny] == 0:
            x = nx
            y = ny
        else:
            break
        turnTime = 0

print(cnt)
```

초기에 내 풀이를 작성했을 때는 3번째 조건을 추가하지 않았다. *이후에 교재 답안을 보고 추가하긴 했으나, 정상 작동을 할지는 미지수다.*

교재에서는 x축과 y축 이동 방식을 미리 리스트 상에서 지정해두고, 도우미 함수를 활용하여 간단하게 회전과 전진 및 후진을 구현하였다. 이전에 왕실의 나이트 문제에서는 8방 좌표를 일일이 리스트에 입력해두길래, 나는 이번에 바라보는 방향도 나왔겠다 딕셔너리 자료구조로 방향에 따라 방향 벡터를 잡는 방식으로 프로그래밍을 했다. 하지만 교재에서는 단순히 x축 y축 방향 벡터만 존재하므로 딕셔너리를 활용하기 보다는 동일 인덱스에 맞춰 x축 y축 성분의 방향 벡터를 구성한 뒤, 이들의 인덱스를 바라보는 방향에 해당하는 숫자로 결정하여 도우미 메소드와 함께 깔끔하게 구현한 모습이다. 이론상으로는 큰 차이는 없다. 리스트의 인덱스를 활용할 것이냐, 아니면 딕셔너리의 키를 활용할 것이냐의 차이일 뿐이다. 그래서 방향 벡터를 표현하는 방식에 있어서는 리스트를 쓰던 딕셔너리를 쓰던 두 방식 다 좋다고 생각한다.

그 다음 차이점은 방문 좌표 맵 구현 방식이다. 나는 그냥 방문한 좌표점들만 저장하려고 튜플 형태로 리스트에 저장했는데, 교재에서는 아예 기존 맵 크기를 그대로 본뜬 후에 전체를 0으로 초기화한 후 해당 포인트에만 1로 값을 변경하는 방식으로 구현하였다. 이렇게 하면 구현하는데 있어 기존 맵과 유사한 메커니즘으로 동작하기 때문에 구현 난이도는 낮아질 수 있다고 보지만, 만약 맵 크기가 무진장 커진다면 메모리 싸움에서 불리해질 수 있다. 그래서 나는 방문 좌표 체크 방식은 방문한 좌표값만 튜플 형태로 리스트에 append하는 내 방식이 더 적합하다고 본다.