# 큰 수의 법칙_py

## 문제 정보

'큰 수의 법칙'은 일반적으로 통계 분야에서 다뤄지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다. 동빈이의 큰 수의 법칙은 다양한 수로 이뤄진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
예를 들어 순서대로 2, 4, 5, 4, 6으로 이뤄진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에는 서로 다른 것으로 간주한다. 예를 들어 순서대로 3, 4, 3, 4, 3으로 이뤄진 배열이 있을 때 M이 7이고, K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로 4+4+4+4+4+4+4인 28이 도출된다.
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.

### 문제 요약

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.

### 입력

- 첫째 줄에 N(2 이상 1000 이하), M(1 이상 10000 이하), K(1 이상 10000 이하)의 자연수가 주어지며, 각 자연수는 공백으로 구분된다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.
- 입력으로 주어지는 K는 항상 M 이하이다.

### 출력

- 첫째 줄에 동빈이의 큰 수의 법칙에 따른 답을 출력한다.

### 예제 입력 1

```python
5 8 3
2 4 5 4 6
```

### 예제 출력 1

```python
46
```

## 문제의 의도

- 리스트를 정렬하여 활용할 수 있는가?

### 아이디어

어차피 주어진 리스트 중에서 가장 큰 수와 두 번째로 큰 수만 활용된다. 그러니 일단 리스트 정렬하고, k번만큼 맨 앞의 수를 더한 후, 딱 한 번만 두 번째로 큰 수를 더하는 것을 반복하는데, 이게 총 m번만큼만 반복되도록 하면 된다. 

### 풀이

```python
n, m , k = map(int, input().split())
nList = list(map(int, input().split()))
nList.sort(reverse=True)

sum = 0
count = 0
while count < m:
    for _ in range(k):
        if count >= m:  break
        sum += nList[0]
        count += 1
    if count >= m:  break
    sum += nList[1]
    count += 1

print(sum)
```

### 풀이 (개선안)

```python
n, m , k = map(int, input().split())
nList = list(map(int, input().split()))
nList.sort(reverse=True)

sum = 0
firstCount = (m // (k+1)) * k + m % (k + 1)
sum += firstCount * nList[0]
sum += (m - firstCount) * nList[1]
print(sum)
```

수학을 활용하면 조잡스러운(?) 반복문을 간단한 코드 몇 줄로 압축시킬 수 있다.

- `m // (k + 1) * k`  : 어차피 우리는 제일 큰 수를 k번 더하고, 두 번째로 큰 수를 1번 더하는 것을 계속 반복해서 진행한다는 것을 알고 있다. 그러니, 한 사이클은 k+1 회만큼 진행된다. 그러므로 m // (k+1)은 전체 진행 횟수 중 단위 사이클을 온전히 몇 번 돌릴 수 있는 지를 뜻한다. 여기에 k를 곱하면, 온전히 돌린 단위 사이클 기준 가장 큰 수를 더한 횟수를 추출할 수 있게 된다.
- `m % (k + 1)` : 전체 덧셈 횟수 중 단위 사이클을 온전히 꽉 채워 돌렸을 때 남은 덧셈 횟수이다. 이 횟수 동안은 확정적으로 가장 큰 수를 더하게 된다. 왜냐하면 마지막 두 번째로 큰 수를 더하게 되면 한 사이클이 온전히 돌아가게 되기 때문이다.
- `m - firstCount` : 전체 덧셈 횟수 중 가장 큰 수를 더하고 남은 나머지 두 번째 수를 더한 횟수이다. 여러 사이클을 돌렸을 때 가장 큰 수를 더한 횟수를 빼면 반드시 두 번째 수를 더한 횟수가 되기 때문이다.

이 문제를 수학적으로 접근해서 풀어볼 생각은 전혀 하지 못했다. 하지만 이 코드 풀이를 보면서, 왜 프로그래밍 방식이 여러 가지로 나뉠 것 같다는 생각이 든다. (가령 R 프로그래밍을 사용하는 프로그래머들과, 웹 개발 프레임워크를 사용하는 프로그래머의 코딩 스타일이 완전히 다를 것 같다는 생각.)  하지만 그렇다고 첫 번째 풀이 방식이 나쁘다? 아 절대 아니다. 

첫 번째 코드는 가독성을 보장하기 때문에 유지보수에 능하다고 할 수 있다. 가령, 요구 사항이 바뀌어도 조금만 조건식을 변형한다거나, 아예 변형하지 않아도 될 수도 있다. 

반면 두 번째 코드는 현재 문제상황을 최적화 방식으로 풀었다고 할 수 있다. 그래서 연산 속도는 첫 번째 방식보다 빠를 것이다. 하지만 코드 자체가 직관적이지 않아서 가독성이 매우 떨어지고, 유지보수하기 어렵다는 단점이 따른다. 요구 사항이 조금만 바뀌어도 다시 수학적인 규칙성을 파악해야 하고, 규칙성 자체가 없는 경우에는 이런 방식의 풀이가 불가능하다는 한계도 있다. 

나는 한 쪽만 편향적으로 연습해서는 안될 거 같다는 생각이 든다. 반드시 두 스타일 모두 연습해야 하며, 그래야 상황에 따라 개발 스타일을 유연하게 변경하여 최적의 개발을 이뤄낼 수 있을 것으로 본다.