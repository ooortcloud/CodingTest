## 문제 정보

마을 사람들은 도로 공사 문제로 머리를 맞대고 회의 중이다. 마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 길마다 길을 유지하는데 드는 유지비가 있다.

마을의 이장은 마을을 2개의 분리된 마을로 분할할 계획을 세우고 있다. 마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.

그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 집의 개수 N, 길의 개수 M이 주어진다. N은 2 이상 100,000 이하 정수이고, M은 1 이상 1,000,000 이하 정수이다.
- 그 다음 줄부터 M개의 줄에 걸쳐 길의 정보가 A, B, C 3개의 정수로 공백으로 구분되어 주어지는데 A번 집과 B번 집을 연결하는 유지비가 C라는 뜻이다. (1 <= C <= 1,000)

### 출력

- 첫째 줄에 길을 없애고 남은 유지비의 합의 최솟값을 출력한다.

### 예제 입력 1

```
7 12
1 2 3
1 3 2
3 2 1
2 5 2
3 4 4
7 3 6
5 1 5
1 6 2
6 4 1
6 5 3
4 5 3
6 7 4
```

### 예제 출력 1

```
8
```

## 풀이

이 문제를 풀기 위해서는 하나의 그래프에서 두 개의 최소 신장 트리를 만들어야 한다. 하나의 최소 신장 트리는 '크루스칼 알고리즘'을 구현하면 쉽게 구할 수 있다. 하지만 동일한 그래프에 크루스칼 알고리즘을 두 번 쓴다고 두 개의 최소 신장 트리가 만들어지진 않는다. 하나의 그래프에는 하나의 최소 신장 트리만 있으니까. 

하지만 그래프를 '분리'하면 '부분 그래프'를 만들 수 있다. 문제에서 두 개의 마을로 분리한다는 조건이 주어졌다. 이 조건에 따르면 우리는 하나의 그래프에서 1번의 분리로 2개의 부분 그래프를 만들 수 있다. 이 조건을 최소 신장 트리에 적용하자. 최소 신장 트리에는 여러 개의 간선들이 있을텐데, 그 중 가중치가 가장 큰 간선을 제거하면 가중치 합이 최소값이 되면서 두 부분 그래프를 만들 수 있다.

```python
import sys

n, m = map(int, input().split())

### 서로소 집합 자료구조 알고리즘
parentTable = [0 for _ in range(n+1)]
for i in range(1, n+1):
    parentTable[i] = i

def find(parentTable, x):
    if parentTable[x] != x:
        parentTable[x] = find(parentTable, parentTable[x])
    return parentTable[x]

def union(parentTable, a, b):
    a = find(parentTable, a)
    b = find(parentTable, b)
    if a < b:
        parentTable[b] = a
    else:
        parentTable[a] = b
### ---

graph = []
for _ in range(m):
    a, b, c = map(int, sys.stdin.readline().split())
    graph.append((c, a, b))

graph.sort()

sum = 0
max_mnt_edge_cost = -1  # MNT에서 가장 마지막에 추가된 간선의 비용을 담아두기 위한 변수
for cost, a, b in graph:
    
    # 사이클이 만들어지면 해당 간선은 무시함
    if find(parentTable, a) == find(parentTable, b):
        continue
    else:
        union(parentTable, a, b)
        sum += cost
        max_mnt_edge_cost = cost

print(sum - max_mnt_edge_cost)  # 가장 마지막에 추가된 간선을 제거하면 (여기서는 비용만 단순 빼기를 했지만) 두 개의 신장 트리가 생성되면서 문제를 해결.
```


```java

```