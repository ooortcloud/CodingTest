# 문제 정보

동네 편의점의 주인인 동빈이는 n개의 동전을 갖고 있습니다. 이때 n개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟값을 구하는 프로그램을 작성하세요.

예를 들어 n=5이고 각 동전이 각각 3, 2, 1, 1, 9원짜리(화폐 단위) 동전이라고 가정합시다. 이때 동빈이가 만들 수 없는 양의 정수 금액 중 최솟값은 8원입니다.

또 다른 예시로 n=3이고 각 동전이 각각 3, 5, 7원짜로 동전이라고 가정합시다. 이때 동빈이가 만들 수 없는 양의 정수 금액 중 최솟값은 1원입니다.

### 입력

- 첫째 줄에 동전의 개수를 나타내는 양의 정수 n이 주어집니다. (1 <= n <= 1,000)
- 둘째 줄에는 각 동전의 화폐 단위를 나타내는 n개의 자연수가 주어지며, 각 자연수는 공백으로 구분합니다. 이때 각 화폐 단위는 1,000,000 이하의 자연수입니다.

### 출력

- 첫째 줄에 주어진 동전들로 만들 수 없는 양의 정수 금액 중 최솟값을 출력합니다.

### 예제 입력

```
5
3 2 1 1 9
```

### 예제 출력

```
8
```

# 풀이

이 문제는 [거스름돈 문제](01.%20거스름돈.md)와는 달리 동전의 개수로 효율을 따지는 문제가 아니다. 어떻게든 제시된 금액만 맞추면 될뿐이다. 그렇기에 거스름돈 문제에서는 효율을 높이기 위해 큰 액수의 동전부터 내림차순으로 소거해 나가는 전략을 선택했다면, 반대로 이 문제에서는 작은 액수의 동전부터 오름차순으로 소거해나가야 빈틈없이 틈새를 메꾸며 금액들을 맞춰나가는 전략을 사용해야 한다. 큰 금액을 먼저 소거하면서 최소 금액을 맞추는 것은 최적해와 거리가 먼 방향성이고 현재 동전을 저렴한 것을 골랐다고 다음에 비싼 금액만 골라야 한다는 조건 같은 건 없으므로, 이 문제는 그리디 알고리즘으로 풀 수 있다. 근데 여기서 한 가지를 더 고민해보아야 한다. 거스름돈 문제는 지금 주어진 금액만 보고 단순히 소거해가며 달리면 되는 문제였는데, 이번 문제는 이전 동전들을 단순 소거해버리면 나중에 이전 동전들을 조합해서 목표 금액을 달성할 수 있을지 없을지를 가늠할 수 없게 된다. 그래서 우리는 **반드시 이전 동전들에 대한 정보를 메모리에 저장시켜가면서 문제를 풀어나가는 알고리즘을 작성해야 한다.**

이미 입력받을 때 메모리에 저장돼있기는 하지만, 그렇다고 매번 리스트 내에 모든 경우의 수를 따져가면서 중첩 반복문을 돌리기에는 시간 복잡도가 너무 높아져서 안된다. 이렇게 이미 메모리에 저장은 돼 있는데 이걸 그대로 쓰기에는 중복 연산이 너무 많아져서 시간 복잡도가 너무 높아지는 경우, **메모이제이션(memoization) 기법**을 사용하여 동일한 반복 연산을 제거함으로써 손쉽게 시간 복잡도를 낮출 수 있다. 이 문제의 경우에는 무려 딱 하나의 변수만 메모리 상에 올려두면 n차 시간에서 선형 시간만큼의 시간 복잡도를 갖게 만들 수 있다! 바로 매번 이전에 꺼낸 동전의 금액만큼 하나의 변수에 중첩시켜 더해 나가는 것이다. 그리고 이렇게 중첩된 금액을 '다음에 만들어야 할 목표 금액'으로 간주하고 풀어 나가면 이 문제를 풀 수 있다. 예를 들어 [1, 2, 4, ...] 리스트가 주어졌을 때, 지정한 변수를 1부터 시작시켜 2, 4, 8... 와 같이 계속 중첩시키며 목표 금액을 점점 높여 나가는 전략이다. 

이 해결방식은 너무 단순해서 빈틈 투성이처럼 보인다. 예컨데 '무슨 자신감으로 단번에 스킵하시는 거죠?'라는 비판적인 의문을 품기 쉽다. 하지만 쉽게 그 원리를 내보일 수 있다. 현재 4를 뽑은 상황이고 이전에 1과 2를 뽑은 상황이라고 하자. 목표 금액은 1원부터 시작하며, 동전 리스트는 오름차순으로 정렬돼 있다. 그러면 목표 변수에 저장된 값은 1+1+2 = 4일 것이다. 그리고 방금 뽑은 4로 4를 만들 수 있다. 그 뿐만 아니라, 우리는 이전에 뽑은 코인들로 4+1, 4+2, 그리고 4+1+2 모든 조합을 완성하여 각각 5, 6, 7을 모두 만들 수 있다. 그러므로 다음 목표 금액은 8이 되어야 하고, 다음 목표 금액과 이전 목표 금액의 차이는 정확히 내가 방금 뽑은 코인의 금액인 4가 된다. 어차피 이전에 뽑은 코인들을 전부 모아봤자 내가 방금 뽑은 코인 한 개의 값어치를 넘어설 수 없고(동일한 금액이 연속으로 나오면 그렇지 않을 수도 있다) 그 중간의 수치들은 전부 꽉꽉 채울 수 있다는 것을 이미 앞에서 증명했기 때문에, 내가 고려해야 할 다음 목표는 정확히 지금까지 내가 뽑아온 코인의 합에서 +1을 한 금액이 된다. 시작 금액을 1로 했기 때문에, 따라서 단순히 내가 뽑은 코인 액수만큼 더해주면 된다.

대신 우리는 반드시 예외 조건을 던져서 무분별한 반복을 끊어내야 한다. 그 예외 조건은 '지금 뽑은 코인의 값어치가 지금까지 더해 온 총 금액보다 클 때'이다. 이전에 뽑은 코인들을 전부 모아봤자 목표 금액을 넘길 수 없는 상황이 오면, 결국 다음에 뽑은 코인의 액수로 목표 금액을 충당하는 방법만이 목표를 달성할 돌파구이다. 그런데 그 다음 패가 목표 금액을 넘어서버리면, 이전에 모은 돈들을 영혼까지 끌어모아도 안되고 방금 뽑은 돈으로 충당하기에는 뽑은 액수가 너무 큰, 이러지도 저러지도 못하는 상황이 된다. 외통수인 것이다. 그러므로 이 예외 조건을 추가적으로 구현해주면 이 알고리즘은 선형 시간 안에 주어진 문제를 완벽히 풀어낼 수 있는 훌륭한 프로그램이 된다. 참고로 그 다음 패가 없는 경우에도 끝이 나야 하므로, 무한 반복문이 아닌 리스트 반복문을 사용해줘야 한다.


```python
n = int(input())
coinList = list(map(int, input().split()))
coinList.sort()

targetAmount = 1
for coin in coinList:
    if(coin > targetAmount):
        break
    else:
       targetAmount += coin 

print(targetAmount)
```

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class MainClass {

	public static void main(String[] args) throws Exception {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n = Integer.parseInt(br.readLine());
		List<Integer> coinList = Arrays.stream(br.readLine().split(" ")).map(Integer::parseInt).sorted().collect(Collectors.toList());
		
		int targetAmount = 1;
		for(int coin : coinList) {
			if (coin > targetAmount) {
				break;
			} else {
				targetAmount += coin;
			}
		}
		
		System.out.println(targetAmount);
	}
}
```