# 1이 될 때 까지_py

## 문제 정보

어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.

1. N에서 1을 뺀다.
2. N을 K로 나눈다.

예를 들어 N이 17, K가 4라고 가정하자. 이 때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다. 이는 N을 1로 만드는 최소 횟수이다.

N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 N(2 이상 100000 이하)과 K(2 이상 100000 이하)가 공백으로 구분되어 각각 자연수로 주어진다. 이때 N은 항상 K 이상의 값으로 주어진다.

### 출력

- 첫째 줄에 최솟값을 출력한다.

### 예제 입력 1

```python
25 5
```

### 예제 출력 1

```python
2
```

## 문제의 의도

- 단순 반복 동작을 뭉쳐서 한 번에 처리할 수 있는가?

### 아이디어

n이 k의 약수가 될 때까지 1씩 빼다가, 약수가 되면 나누는 것을 반복하면 되지.

### 풀이

```python
n, k = map(int, input().split())

count = 0
while n != 1:
    if n % k != 0:
        n -= 1
        count += 1
    else:
        n = n // k
        count += 1

print(count)
```

### 풀이 (개선안)

```python
n, k = map(int, input().split())

count = 0
while n != 1:
    divisor = (n // k) * k
    count += (n - divisor)
    n = divisor // k
    count += 1

print(count)
```

풀이 알고리즘은 동일하다. 하지만, 언제까지 하나씩 빼고 있을 것인가? 백만 단위의 수도 하나씩 빼서 약수에 맞출 것인가? 너무 비효율적이다. 우리는 “24 - 4”를 “24 -1 -1 -1 -1” 형태의 연산으로 하지는 않는다. **효율적인 연산을 위하여 우리는 최소 단위의 연산을 단순 반복하는 것이 아닌, 반복 연산을 가능한 큰 덩어리로 한 번에 연산을 할 수 있어야 한다.**

나눗셈으로 몫을 구하면 미리 다음 목표의 약수를 알 수 있다. 그리고 그 수의 나머지는 우리가 1씩 뺄 횟수와 동일하겠지. 나머지만큼 숫자를 줄여야 몫과 같아질테니. 그러니, 그냥 해당 수의 나머지만큼 카운트를 올리고, 몫에 대해 나눗셈을 진행하면 뺄셈 연산 시간을 함축시켜 크게 줄일 수 있다.

이번 것도 규칙성을 찾아서 사이클을 돌리는 것과 비슷한 느낌의 접근이다. 규칙성을 찾으면 최소 단위 반복 연산을 한 번의 덩어리 연산으로 처리할 수 있다는 장점이 있다. 이런 규칙성을 찾는 팁으로는 한 사이클, 그러니까 하나의 반복되는 구조를 파악하여 단 한 번에 처리할 수 있는 연습을 하면 좋을 것 같다.