# 문제 정보

'큰 수의 법칙'은 일반적으로 통계 분야에서 다뤄지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다. 동빈이의 큰 수의 법칙은 다양한 수로 이뤄진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
예를 들어 순서대로 2, 4, 5, 4, 6으로 이뤄진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에는 서로 다른 것으로 간주한다. 예를 들어 순서대로 3, 4, 3, 4, 3으로 이뤄진 배열이 있을 때 M이 7이고, K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로 4+4+4+4+4+4+4인 28이 도출된다.
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.


### 입력

- 첫째 줄에 N(2 이상 1000 이하), M(1 이상 10000 이하), K(1 이상 10000 이하)의 자연수가 주어지며, 각 자연수는 공백으로 구분된다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.
- 입력으로 주어지는 K는 항상 M 이하이다.

### 출력

- 첫째 줄에 동빈이의 큰 수의 법칙에 따른 답을 출력한다.

### 예제 입력

```
5 8 3
2 4 5 4 6
```

### 예제 출력

```
46
```

# 풀이

### 단순 풀이
```python
n, m, k = map(int, input("N,M,K 입력").split())
numbers = list( map(int, input("입력할 수들을 입력").split()) )
numbers.sort(reverse=True)  # 원본 리스트를 내림차순으로 정렬

# 가장 큰 수를 최대한 많이 반복하면 됨. 개수 초기화 시에는 그 다음으로 큰 수를 딱 한 번 사용해주면 됨.
biggest = numbers[0]
secondary = numbers[1]

sum = 0
tempCnt = 0
for i in range(m):
    if(tempCnt == k):
        sum += secondary
        tempCnt = 0
    else :
        sum += biggest
        tempCnt = tempCnt + 1

print(sum)
```

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public class MainClass {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tempArr = br.readLine().split(" ");
		int n = Integer.parseInt(tempArr[0]);
		int m = Integer.parseInt(tempArr[1]);
		int k = Integer.parseInt(tempArr[2]);
		tempArr = br.readLine().split(" ");

        // Stream API를 사용하여 정렬
		List<Integer> numberList = Arrays.stream(tempArr).map(Integer::parseInt).sorted(Comparator.reverseOrder()).collect(Collectors.toList());

		int biggest = numberList.get(0);
		int secondary = numberList.get(1);
		
		int sum = 0;
		int cnt = 0;
		// k번만큼 가장 큰 값을 더하기. k번째마다 두 번째로 큰 값을 더하여 규칙 초기화.
		for(int i = 0; i < m; i++) {			
			if(cnt == k) {
				sum += secondary;
				cnt = 0;
			} else {
				sum += biggest;
				cnt++;
			}
		}
		
		System.out.println(sum);
	}
}
```

### 심화 풀이

단순 반복문으로 풀게될 경우, data의 개수가 매우 많아질 경우 시간 초과 판정을 받을 수 있다. 시간초과를 피하기 위해서는 규칙을 수식화하여 단순하게 정의할 필요가 있다.

위 문제에서는 매 k번째마다 두 번째로 큰 값을 더하고, 이외에는 가장 큰 값을 더해주는 규칙이 있다. 이는 단순 반복문을 사용할 필요없이, 첫 번째로 큰 값과 두 번째로 큰 값이 각각 몇 번 더해지는지를 계산할 수만 있다면 단순 곱셈 및 합으로 답을 구할 수가 있다.
- 가장 큰 값이 더해지는 횟수 = M / (K + 1) * K + M % (K + 1)
- 두 번째로 큰 값이 더해지는 횟수 = M - ( 가장 큰 값이 더해지는 횟수 )

이를 반영하여 코드를 일부 수정하면 다음과 같이 표현할 수 있다.
```python
sum = 0
biggestCnt = int( m / (k + 1) ) * k + m % (k + 1)
sum += biggest * biggestCnt
sum += secondary * (m - biggestCnt)

print(sum)
```

```java
int sum = 0;
int biggestCnt = m / (k + 1) * k + m % (k + 1);
sum += biggest * biggestCnt;
sum += secondary * (m - biggestCnt);

System.out.println(sum);
```