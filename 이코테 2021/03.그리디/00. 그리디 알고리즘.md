# 그리디 알고리즘(탐욕 알고리즘, Greedy Algorithm)

'모든 부분 문제의 최적해가 전체 문제의 최적해에 포함되며 현재의 선택이 다음 선택지에 영향을 미치지 않는 경우, 현재 가장 좋은 선택지를 고르는 것이 최적해이다.'는 파격적인 조건을 제시하는 알고리즘. 정확하지는 않지만 쉽게 표현하자면, **동일한 논리로 조건이 좋아질수록 최적해에 가까워지며 현재의 선택이 다음 선택에 예측할 수 없는 장애를 일으키지 않는다면, 현재 가장 좋은 선택지만 골라도 최적해에 도달할 수 있다**는 의미이다. '모든 부분 문제의 최적해가 전체 문제의 최적해에 포함' 이 내용이 받아들이기 난해한데, 쉽게 말해서 매 선택마다 논리 로직을 전혀 수정하지 않고 정적인 논리 로직만 그대로 수행하면 자연스레 최적해에 다다를 수 있다는 말이다. 그래서 그리디 알고리즘은 핵심 명제에 가장 이상적인 상황이 나오도록 정렬 알고리즘 또는 우선순위 큐 자료구조와 같이 사용하는 경우가 많다. 그리디 알고리즘은 모든 문제에 대해서 항상 고려해볼법한 범용성과 조건이 맞아 떨어졌을 때 우수한 성능을 모두 갖고 있기 때문에, 알고리즘에 입문하는 사람이라면 무조건 그리디 알고리즘을 먼저 이해하고 넘어가야 한다.

그러나 대부분의 경우 수많은 경우 중 논리 로직의 반례(ex. 큰 금액이 아닌 중간 금액부터 처리하는 것이 더 이득일 때가 있던데?)가 나온다거나 현재의 선택이 다음 선택지에 제한을 가한다는 등 조건을 만족하지 못하여 탐욕 알고리즘으로 최적해를 구하지는 못하며, 대신 계산 속도가 빠르기 때문에 주로 최적해를 근사적으로 구할 때 사용한다. 만약 주어진 문제에서 그리디 조건을 만족하지 못하는 경우, 그 문제는 모든 경우를 다 따져가며 모든 결과를 전부 메모리에 저장해두고 전체 결과 중 최적해를 반환하는 '다이내믹 프로그래밍(동적계획법)'으로 해결할 수 있다.

그리디 알고리즘은 어떤 선택을 해도 미래가 바뀌지 않는 성질을 갖고 있어 미리 예상하고 계산하는 것이 가능해서 연산 압축이 가능하다. '중복 연산' 문제 때문에 성능이 최악이 된다면, '메모이제이션 기법'을 적용해보는 것을 추천한다. 한편 중복이 아니라 '사이클 중첩 연산' (순환하며 누적되는 연산을 요구하는 조건의 가제)때문에 성능이 최악이 되는 경우, 가장 반복 횟수를 줄일 수 있는 사이클 기준을 잡아서 연산을 압축하여 복잡도를 크게 낮출 수 있다. 개인적으로는 주어진 조건에 해당하는 사이클을 기준으로 잡은 뒤, 그 사이클에 적합한 자료구조를 만들면 효율적이면서도 간편한 솔루션을 낼 수 있었던 것 같다.

# 그리디 알고리즘의 정당성 평가

먼저 아래의 거스름돈 문제를 풀어보고 이어지는 글을 읽으라.

[거스름돈 문제](01.%20거스름돈.md)

만약 위 문제에서 주어지는 거스름돈 단위가 서로 나누어 떨어지지 않았다면, 이 문제는 '무조건 큰 금액이 장땡'이라는 논리를 갖고 그리디 알고리즘으로 풀 수 없다. 예를 들어 500원, 400원, 100원 세 종류의 동전이 있을 때 800원을 최소한의 동전 개수로 거슬러주는 가장 최적의 해는 400원 2개를 지불하는 것이다. 하지만 만약 그리디 알고리즘을 그대로 적용했을 때 500원부터 내림차순으로 뽑는 가장 이상적인 경우 항상 500원 1개에 100원 3개라는 오히려 퇴보하는 결과를 보여주게 되므로, 이런 경우에는 그리디 알고리즘으로 해결하려고 해서는 안된다.

이러한 명제들의 타당성을 검토하는 실력을 키우려면 문제를 미리 많이 풀어보는 수밖에 없다. 현장에서 모든 예외 케이스를 찾으려고 시도할 수는 없기 때문이다. 그리디 문제는 100% 센스 싸움이다.

만약 주어진 문제에서 위의 비대칭 거스름돈 문제와 같이 예외 상황이 발생하는 경우, 그 문제를 '다이내믹 프로그래밍'으로 해결할 수 있다는 것을 알아두자.