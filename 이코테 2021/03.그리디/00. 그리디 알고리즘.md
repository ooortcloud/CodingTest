# 그리디 알고리즘(탐욕 알고리즘, Greedy Algorithm)

그리디 알고리즘은 '현재 주어진 것들 중 가장 좋은 선택지만 고르는 방법론'이다. 미래에 어떤 악영향이 발생할지는 전혀 고려하지 않는 무책임한(?) 알고리즘이다. 그리디 알고리즘은 개념은 쉬운데 특정한 유형이 없어서 단순 암기가 무용지물이다. 그래서 그리디 알고리즘을 쓰기 위해서 우리는 딱 한 가지만 생각하면 된다. 

**'현재 주어진 것들 중 가장 좋은 것만 골라도 풀 수 있는 문제인가?'**

이 질문에 Yes라고 할 수 있다면 그 문제는 그리디 알고리즘으로 풀면 되고, No라면 그리디 알고리즘으로 풀 수 없는 문제다.

그리디 알고리즘은 가장 좋은 선택지의 기준이 무엇이든 결국 '우선순위 순서'를 매겨서 선택지를 평가해야만 한다. 순서를 매긴 후 가장 우선순위가 높은 선택지를 고르면 되므로, 그리디 알고리즘을 구현하려면 정렬 알고리즘까지 구현해야 한다. 다행히 대부분의 프로그래밍 언어에는 다양한 정렬 라이브러리를 제공해준다.

# 그리디 알고리즘의 정당성 평가

먼저 아래의 거스름돈 문제를 풀어보고 이어지는 글을 읽으라.

[거스름돈 문제](01.%20거스름돈.md)

만약 위 문제에서 주어지는 거스름돈 단위가 서로 나누어 떨어지지 않았다면, 이 문제는 그리디 알고리즘으로 풀 수 없다. 예를 들어 500원, 400원, 100원 세 종류의 동전이 있을 때 800원을 최소한의 동전 개수로 거슬러주는 가장 최적의 해는 400원 2개를 지불하는 것이다. 하지만 그리디 알고리즘으로 풀면 항상 500원 1개에 100원 3개라는 속 터지는 출력만 할뿐이다.

그래서 그리디 알고리즘을 적용하려면 반드시 먼저 '이 문제를 풀기 위해 그리디 알고리즘을 사용하는 것이 정당한가?'를 검토해야만 한다. 위 문제를 그리디 알고리즘으로 풀 수 있었던 근거는 '각 동전의 단위가 서로 정비례 관계'였기 때문이다. 각 동전이 서로 정비례 관계면 항상 최적의 선택지만 골라서 거슬러주는 것보다 더 나은 예외 케이스는 발생하지 않는다. 이 명제가 정당한지는 어쩔 수 없이 현장에서 주어진 시간 내에 하나씩 따져보는 수밖에 없다. 만약 예외를 놓쳤다면 당신이 그리디 알고리즘으로 풀었을 때 반드시 틀리고, 예외가 없는 문제였다면 그리디 알고리즘으로 풀면 매우 쉽게 풀 수 있던 문제인 것이다. 이러한 예외를 찾아내는 건 노가다 내지는 센스(도메인) 싸움이다. 그리고 예외를 찾거나 예외가 없음을 확신할 확률을 높이기 위해서는 코딩 테스트를 꾸준히 풀어보면서 경험을 쌓는 수밖에 없다.

만약 주어진 문제에서 반드시 예외 상황이 발생하는 경우에는 그 문제를 '다이내믹 프로그래밍'으로 해결할 수 있다.