# 문제 정보

숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.

1. 숫자가 쓰인 카드들이 N * M 형태로 놓여있다. 이 때 N은 행의 개수, M은 열의 개수를 의미한다.
2. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
3. 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑는다.
4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

카드들이 N * M 형태로 놓여 있을 때, 게임의 룰에 맞게 카드를 뽑는 프로그램을 만드시오.

### 입력

- 첫째 줄에 쓰일 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 주어진다. (N과 M은 1 이상 100 이하)
- 둘째 줄부터 N개의 줄에 걸쳐 각 카드가 적힌 숫자가 주어진다. 각 숫자는 10000 이하의 자연수이다.

### 출력

첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.

### 예제 입력 1

```
3 3
3 1 2
4 1 4
2 2 2
```

### 예제 출력 1

```
2
```

### 예제 입력 2

```
2 4
7 3 1 8
3 3 3 4
```

### 예제 출력 2

```
3
```

# 풀이

```python
n, m = map(int, input("n, m 값을 입력").split())

# n번 반복하며 카드 행을 입력받음
cardList = list()
for i in range(n):
    # 카드 행을 항상 내림차순으로 정렬 후 append
    temp = list(map(int, input("카드 행을 입력").split()))
    temp.sort()
    cardList.append( temp ) 

print(cardList)

# 매 카드 행마다 최소값을 비교하여, 더 큰 경우 갱신
minVal = 1
for tempList in cardList:
    tempMinVal = tempList[0] 
    if(minVal < tempMinVal):
        minVal = tempMinVal

print(minVal)
```

위 풀이는 전체 data를 모두 memory 상에 넣은 후에 연산을 진행하는 단순한 풀이이다. 하지만 굳이 모든 값을 memory 상에 올려놓지 않고 연산하는 방법을 사용하는 것이 더 좋은 풀이이다.

```python
n, m = map(int, input("n, m 값을 입력").split())

# n번 반복하며 카드 행 내 최소값이 크면 갱신
minVal = 1
for i in range(n):
    # 카드 행을 항상 내림차순으로 정렬 후 append
    temp = list(map(int, input("카드 행을 입력").split()))
    temp.sort()
    if(minVal < temp[0]):
        minVal = temp[0]

print(minVal)
```

```python
n, m = map(int, input("n, m 값을 입력").split())

# n번 반복하며 카드 행 내 최소값이 크면 갱신
minVal = 1
for i in range(n):
    # 카드 행을 항상 내림차순으로 정렬 후 append
    temp = list(map(int, input("카드 행을 입력").split()))
    tempMinVal = min(temp)
    if(minVal < tempMinVal):
        minVal = tempMinVal

print(minVal)
```

위 두 풀이는 모두 각 행마다 최소값을 찾아서 결과값을 덮어쓰는 풀이이다. 첫번째 풀이의 경우 정렬을 사용하기 때문에 시간복잡도는 O(NlogN)이다. 반면 두번째 풀이는 단순히 python에서 제공하는 최소값 함수를 사용하기 때문에 시간복잡도는 O(N)이다. 그러므로 정렬을 사용하지 않는 두 번째 풀이가 효율적이다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class MainClass {

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  // BufferedReader은 항상 문자 stream만 읽을 수 있음
		StringTokenizer tempArr = new StringTokenizer( br.readLine() );  // 공백을 기준으로 문자열 token 생성 (default가 공백임)
		int n = Integer.parseInt(tempArr.nextToken());
		int m = Integer.parseInt(tempArr.nextToken());
		
		int minVal = 1;
		for(int i = 0; i < n; i++) {
			tempArr = new StringTokenizer( br.readLine() );
			// 주어진 행 내에서 가장 작은 수 찾기
			int tempMinVal = 10001;
			for(int j=0; j<m; j++) {
				tempMinVal = Math.min(Integer.parseInt(tempArr.nextToken()), tempMinVal);
			}
			// 주어진 행 내 최소값과 전체 행 내 최소값 비교하여 더 큰 수를 선택
			minVal = Math.max(minVal, tempMinVal);
		}
		
		System.out.println(minVal);
	}
}
```