# 00. 설명

# 목차

- [00. 설명](#00-설명)
- [목차](#목차)
- [범위를 반씩 좁혀가는 탐색](#범위를-반씩-좁혀가는-탐색)
  - [순차 탐색](#순차-탐색)
    - [순차 탐색 예제 코드](#순차-탐색-예제-코드)
    - [실행 결과](#실행-결과)
  - [이진 탐색 : 반으로 쪼개면서 탐색하기](#이진-탐색--반으로-쪼개면서-탐색하기)
    - [재귀함수로 구현한 이진 탐색](#재귀함수로-구현한-이진-탐색)
    - [반복문으로 구현한 이진 탐색](#반복문으로-구현한-이진-탐색)
    - [실행 결과](#실행-결과-1)
    - [코딩 테스트에서의 이진 탐색](#코딩-테스트에서의-이진-탐색)
  - [트리 자료 구조](#트리-자료-구조)
  - [이진 탐색 트리](#이진-탐색-트리)
    - [빠르게 입력받기](#빠르게-입력받기)


# 범위를 반씩 좁혀가는 탐색

## 순차 탐색

**`순차탐색`이란 리스트 안에 있는 특정 데이터를 찾기 위해 리스트 처음부터 끝까지 하나씩 차례대로 확인하는 탐색 방법이다.** 최악의 경우 시간 복잡도는 $O(N)$을 보장한다. 리스트의 정렬 여부에 관계없이 탐색이 가능하다는 점이 그나마 장점이다.

### 순차 탐색 예제 코드

```python
def sequentialSearch(n, target, array):
    for i in range(n):
        if array[i] == target:
            return i + 1  # 현실에서의 리스트는 첫 번째부터 시작하므로 보정.

inputData = input().split()
n = int(inputData[0])  # 원소의 개수
target = inputData[1]

array = input().split()

print(sequentialSearch(n, target, array))
```

### 실행 결과

```
5 d
a b d c e
3
```

## 이진 탐색 : 반으로 쪼개면서 탐색하기

**`이진 탐색`은 찾으려는 데이터와 중간점 위치의 데이터를 반복적으로 비교하여 반으로 쪼개면서 데이터를 찾는 과정이다.** 단, 이진 탐색을 사용하려면 배열 또는 리스트 내부가 오름차순 또는 내림차순으로 정렬되어 있어야 한다는 전제 조건이 있다. 

동작 방식을 예제를 통해 이해해보자.

![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%2020049167bd6b429688ea356bd137b923/Untitled.png)

![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%2020049167bd6b429688ea356bd137b923/Untitled%201.png)

위 예제에서, 전체 리스트 내 요소 개수는 10개였지만 단 3번 만에 원하는 데이터를 찾을 수 있었다. 이진 탐색을 한 번 할 때마다 탐색해야 하는 리스트의 길이가 절반씩 줄어들기 때문에 연산 횟수는 $log_2{N}$에 비례하며, 따라서 시간복잡도는 빅오 표기법에 따라 $O(logN)$이다. 이는 피벗값을 기준으로 리스트를 반씩 자르는 퀵정렬과 유사한 부분이다.

이진 탐색은 재귀 함수, 반복문 어떤 방식으로도 구현이 가능하다. 

### 재귀함수로 구현한 이진 탐색

```python
def binarySearch(array, target, start, end):
    if start > end:
        return None
    
    mid = (start + end) // 2  # 소수점 버림 연산
    
    if array[mid] == target:
        return mid
    elif array[mid] > target:  # 리스트 오른쪽 절반 버림
        return binarySearch(array, target, start, mid - 1)
    else:   # 리스트 왼쪽 절반 버림
        return binarySearch(array, target, mid + 1, end)

n, target = map(int, input().split())

array = list(map(int, input().split()))

result = binarySearch(array, target, 0, n-1)
if result == None:
    print("해당 원소는 존재하지 않음")
else:  print(result + 1)
```

### 반복문으로 구현한 이진 탐색

```python
def binarySearch(array, target, start, end):
    while start <= end :
        mid = (start + end) // 2
        if array[mid] == target:
            return target
        elif array[mid] > target:
            end = mid - 1
        else:
            start = mid + 1
    return None

n, target = map(int, input().split())

array = list(map(int, input().split()))

result = binarySearch(array, target, 0, n-1)
if result == None:
    print("해당 원소는 존재하지 않음")
else: print(result + 1)
```

### 실행 결과

```
10 7
1 3 5 7 9 11 13 15 17 19
4

10 8
1 3 5 7 9 11 13 15 17 19
해당 원소는 존재하지 않음
```

### 코딩 테스트에서의 이진 탐색

이진 탐색의 원리는 정말 폭넓게 사용되기 때문에 매우 중요하다고 할 수 있다. 코드가 짧지만 막상 구현하려고 하면 꽤 까다로우며, 코딩 테스트에서도 단골 출제되므로 반드시 외우도록 하자. 

코딩 테스트의 이진 탐색 문제는 주로 탐색 범위가 매우 큰 상황에서 자주 출제된다. 탐색 범위가 대략 2,000만을 넘어가면 ‘이진 탐색 문제인가…?’ 하고 문제에 접근해보도록 하자. 참고로, 처리해야 할 데이터량이 1,000만을 넘어가면 시간 복잡도 $O(logN)$을 보장하는 이진 탐색(또는 이와 비슷한 시간 복잡도를 가진 알고리즘)을 써야 풀 수 있는 문제가 많다고 한다.

## 트리 자료 구조

**`트리 자료구조` 는 계층적인 구조를 가지며, 노드(Node)들이 연결되어 있는 구조이다.** “노드”는 어떤 데이터를 갖고 있는 객체 정도로 생각하면 된다. 트리도 그래프 자료구조의 일종으로, 그 때 그 노드와 동일한 개념이다. 트리 자료구조는 주로 DB나 파일 시스템 같은 곳에서 많은 양의 데이터를 관리하기 위해 사용된다. 트리 자료구조는 이진 탐색과 비슷한 형태로 동작하여 빠른 탐색을 보장한다. 대신 이진 탐색과 동일하게 항상 데이터가 정렬되어 있어야 한다는 조건이 있다.

트리의 특징은 아래와 같다.

- 트리는 “부모 노드”와 “자식 노드”의 관계로 표현한다.
- 트리의 최상단 노드를 “루트 노드”라고 부른다.
- 트리의 최하단 노드를 “단말 노드”라고 부른다.
- 트리의 일부를 떼어낸 것을 “서브 트리”라고 한다. 떼어낸 서브 트리는 항상 트리 구조를 보장한다.

## 이진 탐색 트리

**`이진 탐색 트리`는 이진 탐색이 동작할 수 있도록 고안된 효율적이면서 가장 간단한 트리 자료구조이다.** 다른 말로 하자면, 모든 트리 구조는 반드시 이진 탐색 트리처럼 동작하지는 않는다. 그저 이와 비슷할 뿐이다.

이진 탐색 트리는 아래의 특징을 갖는다.

- 왼쪽 자식 노드는 반드시 부모 노드보다 작다.
- 오른쪽 자식 노드는 반드시 부모 노드보다 크다.

그래서 마치 퀵정렬처럼 부모 노드를 기준으로 두 개의 서브 트리로 반으로 갈린 형태가 이뤄지게 된다. 

이진 탐색 트리의 데이터 탐색 과정은 이진 탐색과 동일하다. 루트 노드부터 시작해서, 해당 노드와 탐색하는 값을 서로 비교하여, 작으면 왼쪽 자식 노드를 선택하고 크면 오른쪽 자식 노드를 선택하는 식으로 탐색을 진행한다. 이는 이진 탐색에서 중간점을 기준으로 값을 비교하여 리스트 절반을 반씩 잘라버리는 형태와 똑같다.

### 빠르게 입력받기

이진 탐색 문제는 대부분 입력 데이터가 너무 많거나 탐색 범위가 너무 넓다. 그래서 이 경우에 반드시 “sys” 라이브러리의 “readline()” 함수를 사용하여 입력값을 받아야 한다.

```python
import sys
inputData = sys.stdin.readline().rstrip()  # 하나의 문자열 데이터를 입력받는다.

print(inputData)
```

sys 라이브러리를 사용할 때 반드시 rstrip() 함수를 호출해야 한다. 그렇지 않으면 줄바꿈 기호까지 한 번에 문자열에 담겨서 골치아파진다.

개인적으로는 "split()"를 원활하게 사용하기 위해 아래의 방식을 추천한다. 
```python
import sys
inputData = sys.stdin.readline

print(inputData().rstrip().split())
```