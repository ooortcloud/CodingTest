# 02. 떡볶이 떡 만들기

## 문제 정보

오늘 동빈이는 여행 가신 부모님을 대신해서 떡집 일을 하기로 했다. 오늘은 떡볶이 떡을 만드는 날이다. 동빈이네 떡볶이 떡은 재밌게도 떡볶이 떡의 길이가 일정하지 않다. 대신에 한 봉지 안에 들어가는 떡의 총 길이는 절단기로 잘라서 맞춰준다.

절단기에 높이(h)를 지정하면 줄지어진 떡을 한 번에 절단한다. 높이가 h보다 긴 떡은 h 위의 부분이 잘릴 것이고, 낮은 떡은 잘리지 않는다.

예를 들어 높이가 19, 14, 10, 17cm인 떡이 나란히 있고 절단기 높이를 15cm로 지정하면 자른 뒤 떡의 높이는 15, 14, 10, 15cm가 될 것이다. 잘린 떡의 길이는 차례대로 4, 0, 0, 2cm이다. 손님은 6cm만큼의 길이를 가져간다.

손님이 왔을 때 요청한 총 길이가 m일 때 적어도 m만큼의 떡을 얻기 위해 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 떡의 개수 n과 요청한 떡의 길이 m이 주어진다. (n은 1 이상 1백만 이하, m은 1 이상 20억 이하)
- 둘째 줄에는 떡의 개별 높이가 주어진다. 떡 높이의 총합은 항상 m 이상이므로, 손님은 필요한 양만큼 떡을 사갈 수 있다. 높이는 10억보다 작거나 같은 양의 정소 또는 0이다.

### 출력

- 적어도 m만큼의 떡을 집에 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.

### 예제 입력 1

```
4 6
19 15 10 17
```

### 예제 출력 1

```
15
```

## 문제의 의도

- 문제의 해결책을 구현할 수 있는가?

### 아이디어

- 절단기로 자른 떡의 길이를 리스트에 저장한 후, 순차적으로 절단기의 길이를 높여가면서 해당 리스트 요소의 전체 합이 m보다 작은 최초의 h를 찾는다. 이때의 “h - 1” 값은 조건을 만족하는 절단기의 최대 높이를 보장한다. h는 1부터 1cm씩 증가시키면서 반복 탐색.

### 풀이 (아마도 오답)

```python
n, m = map(int, input().split())

myList = list(map(int, input().split()))
leftovers = list()

for h in range(1, max(myList)-1):
    for i in range(n):
        temp = myList[i]
        if temp > h:
            leftovers.append(temp - h)
        else:
            leftovers.append(0)
    
    # 최초로 남는 떡의 길이가 조건을 넘지 못하는 경우, 이전 절단기의 높이가 가장 높은 값임.
    if sum(leftovers) < m:
        print(h - 1)
        break

    leftovers.clear()
```

하지만 이런 순차 탐색 풀이? 만약 시간이 타이트하게 주어진다면 정답 처리가 되지 않을 수 있다. 최악의 경우인 10억에 해당하는 높이까지 시간 내에 순차 탐색으로 나아갈 수 있을 것이라 장담할 수 있는가? 난 자신 없다. 10억이라는 숫자는 너무 압도적이다. 

이런 말도 안되는 숫자 범위에서 탐색해야 한다…? 이제는 당연하게 `이진 탐색`이 떠올라야 한다.

### 답안 풀이

사실 이 문제는 “파라메트릭 서치” 유형의 문제, 즉 전형적인 이진 탐색 문제이다. 파라메트릭 서치란 최적화 문제를 “True or False” 문제로 바꾸어 해결하는 방식이다. 주로 “원하는 조건을 만족하는 가장 최적의 값”을 찾는 문제들에 파라메트릭 서치 방식이 자주 쓰인다. 그리고 이런 파라메트릭 서치 방식을 구현하기 위해 주로 “이진 탐색”을 이용하는 편이다.

절단기의 높이는 최소 1부터 최대 10억까지 정수이므로, 만약 순차 탐색을 했을 경우 최악의 경우는 10억 번 탐색을 해야 한다. 하지만 이진 탐색을 한다면 최악의 경우까지 총 31번 정도밖에 걸리지 않는다.

```python
n, m = map(int, input().split())

myList = list(map(int, input().split()))

# 최소 높이는 0, 최대 높이는 현존하는 최장 길이의 떡의 길이이므로 범위를 이와 같이 잡는다.
start = 0
end = max(myList)

result = 0
while(start <= end):
    total = 0
    mid = (start + end) // 2
    for x in myList:
        if x > mid:
            total += x - mid

    if total < m:
        end = mid - 1  # 중간값의 길이도 노답임을 알았으니 중간 전 값까지만 탐색해도 됨.
    else:
        start = mid + 1  # 중간값의 길이도 노답임을 알았으니 중간 후 값부터 탐색해도 됨.
        result = mid  # m 이상이기만 하면 조건 만족이므로 일단 값 갱신.

print(result)
```

파라메트릭 서치 문제는 일반적인 이진 탐색 문제와는 다르게 주어진 리스트에 대한 정렬을 요구하지 않는다. 하지만 길이에 대해서 이진 탐색 조건 처리를 해야 하므로, 길이에 대한 상태 변수를 따로 관리해줘야 한다. 이 부분은 재귀함수로 구현하기 귀찮기 때문에 반복문으로 구현해서 푸는 것이 편하다.