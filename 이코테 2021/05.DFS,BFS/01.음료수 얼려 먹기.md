# 01.음료수 얼려 먹기

## 문제 정보

N*M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 

팁) 0으로 이뤄진 부분끼리 모여서 하나의 아이스크림을 생성할 수 있다. 크기 상관없이 하나로 카운트.

### 문제 요약

얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 

### 입력

- 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. (1 이상 1000 이하)
- 두 번째 줄부터 N+1번째 줄까지 얼음 틀의 형태가 주어진다.
- 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

### 출력

- 한 번에 만들 수 있는 아이스크림의 개수를 출력한다.

### 예제 입력 1

```python
4 5
00110
00011
11111
00000
```

### 예제 출력 1

```python
3
```

### 예제 입력 2

```python
15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111
```

### 예제 출력 2

```python
8
```

## 문제의 의도

- 수 많은 1과 0 가운데 0의 묶음을 만들어서 개수를 카운트할 수 있는가?

### 아이디어

- 우선 필드 데이터를 받고, (0,0)지점에서 시작해서 동서남북으로 자기 좌표의 주변을 살펴보면서 0이면 진출하고 1이면 정지하면서 0 그룹을 만든다.
- 하나의 0그룹을 만들었으면, 방문하지 않은 다음 0을 찾아 단순 탐색한다.

### 풀이

시간 관계 상 답안을 참고하였다.

주요 아이디어는 다음과 같다.

1. 특정 지점의 주변 상하좌우를 살펴본 뒤에 주변 지점 중 값이 0이면서 동시에 아직 방문하지 않은 지점이라면 해당 지점을 방문한다. 맵 밖을 벗어나거나 이미 방문했던 곳이라면 해당 스택 브랜치는 종료한다.
2. 새로 방문한 지점의 노드값을 1로 변환한다. (이렇게 하면 방문 리스트를 구현하지 않아도 됨.) 그리고 방문한 지점에서 다시 상하좌우를 살펴보면서 1번을 반복한다.
3. 1~2번 과정을 모든 노드에 대해 반복하면서 방문하지 않은 지점의 수를 센다.

```python
n, m = map(int, input().split())

graph=list()
for i in range(n):
    graph.append(list(map(int, input())))

def dfs(x, y):  # raw 축을 x, columm 측을 y로 잡음
    # 맵 밖을 벗어나는 경우 함수 종료
    if x<=-1 or x >=n or y<=-1 or y>=m:
        return False
    # 현재 노드가 방문하지 않은 0번 노드라면?
    if graph[x][y] == 0:
        graph[x][y] = 1  # 1번 노드로 변환시키면서 방문처리
        # 현재 노드의 주변 노드에 대해 재귀 탐색
        dfs(x-1, y)
        dfs(x+1, y)
        dfs(x, y-1)
        dfs(x, y+1)
        return True
    # 현재 노드가 방문했던 노드 또는 1번 노드라면 함수 종료
    return False

cnt = 0
# 노드 전체 탐색
for x in range(n):
    for y in range(m):
        # 내부적으로 True가 중첩되더라도, 여기서 최초로 들어간 i&j의 리턴값에 대해서만 유효성 검사 진행.
        if dfs(x, y) == True:
            cnt += 1

print(cnt)
```

입력 관련 주의 사항: 

- “input = sys.stdin.readline” 으로 변환 후 input을 받으면 “\n”까지 같이 리스트에 저장해버린다. 그래서 상황에 따라서 순수 input() 메소드를 쓰는 것도 좋아 보인다.
- 무심코 map(int, input().split())을 해버리면 공백없이 이뤄진 숫자형 문자열을 구분해내지 못한다. 그래서 split()을 빼고 사용해줘야 숫자 하나 하나를 끊어서 리스트에 담아준다.