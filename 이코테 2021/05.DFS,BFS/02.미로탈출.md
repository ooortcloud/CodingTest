# 02.미로 탈출

## 문제 정보

동빈이는 N*M 크기의 직사각형 형태의 미로에 갇혀 있다. 미로에는 여러 마리의 괴물이 있어 이를 피해 탈출해야 한다. 동빈이의 위치는 (1,1)이고 미로의 출구는 (N,M)의 위치에 존재하며 한 번에 한 칸씩 이동할 수 있다. 이때 괴물이 있는 부분은 0으로, 괴물이 없는 부분은 1로 표시되어 있다. 미로는 반드시 탈출할 수 있는 형태로 제시된다. 이때 동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구하시오. 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산한다.

### 문제 요약

동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구하시오.

### 입력

- 첫째 줄에 두 정수 N, M(4이상 200이하)이 주어진다.
- 다음 N개의 줄에는 각각 M개의 정수 (0 또는 1)로 미로의 정보가 주어진다. 각 수들은 공백 없이 붙어서 입력으로 제시된다. 또한 시작 칸과 마지막 칸은 항상 1이다.

### 출력

- 첫째 줄에 최소 이동 칸의 개수를 출력한다.

### 예제 입력 1

```python
5 6
101010
111111
000001
111111
111111
```

### 예제 출력 1

```python
10
```

## 문제의 의도

- 길을 찾아내면서 동시에 가장 최소 경로를 구하라.

### 아이디어

- 일단 길부터 뚫자.

### 풀이

- 내 풀이(오답)

```python
n, m = map(int, input().split())

graph = list()
for _ in range(n):
    graph.append(list(map(int, input())))

def dfs(x, y):
    global cnt
    cnt += 1
    # 필드 벗어나면 종료
    if x<=-1 or x>=n or y<=-1 or y>=m:
        return
    # 목적지 도착하면 종료
    if x == n-1 and y == m-1:
        return
    # 길을 발견한 경우 탐색 진행
    if graph[x][y] == 1:
        dfs(x-1, y)
        dfs(x+1, y)
        dfs(x, y-1)
        dfs(x, y+1)
        return
    
cnt = 0
dfs(0, 0)
print(cnt)
```

문제점이 두 가지가 있다.

1. 어떻게 해야 최솟값을 구할 수 있는지 모르겠음.
2. “RecursionError: maximum recursion depth exceeded” 최대 재귀 횟수를 넘어버림. 이렇게 푸는 문제가 아닌 듯함.
- 모범 답안

```python
from collections import deque

n, m = map(int, input().split())

graph = list()
for _ in range(n):
    graph.append(list(map(int, input())))

# [상, 하, 좌, 우]
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def bfs(x, y):  # 시작 좌표 (재귀로 쓰지 않을 거임)
    # bfs 방식은 큐 자료구조를 사용
    queue = deque()
    queue.append((x, y))  # 좌표는 튜플 형태로 저장 -> 언패킹으로 꺼내 쓸 거임.

    # 재귀 방식이 아니기 때문에 루프로 반복시킴.
    while queue: 
        x,y = queue.popleft()
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            # 맵 밖을 벗어나는 경우는 제외
            if nx <= -1 or nx >= n or ny <= -1 or ny >= m:
                continue
            # 값이 0인 경우도 제외
            if graph[nx][ny] == 0:
                continue
            # 처음 방문하는 정상적인 길인 경우에만 큐에 push하고 거리 기록
            if graph[nx][ny] == 1:
                graph[nx][ny] = graph[x][y] + 1
                queue.append((nx, ny))

    return graph[n-1][m-1]  # 목적지에 저장될 값이 곧 최소 거리가 됨.

    
print(bfs(0, 0))
```

이번에는 DFS가 아닌 BFS로 문제를 해결한다. 큐 자료구조와 루프를 사용하여 문제를 해결한다.

최솟값을 구하는 방법은 간단하다. 노드 값을 1씩 증가시키면, 해당 위치에서의 이동 칸 수를 기록해 둘 수 있다. 그러므로 진행할 수 있는 길만 선택하고, 해당 길에 저장된 값을 이전 값으로부터 계속 1씩 누적해서 나아가다 보면 목적지에 도착했을 때 즈음에는 반드시 최소값을 갖게 된다.

- 0일 때에는 애초에 갈 수 없는 길이므로 continue
- 맵을 벗어나는 경우도 continue
- 노드 값이 1인 경우만 진행하도록 함. 지금 위 문제도 별도의 방문 리스트를 구현하지 않았는데, 왜냐하면 노드 값을 누적시키면 반드시 1보다 크기 때문에 조건에 걸리지 않아서 이전에 왔던 길로 되돌아갈 일이 없음.

참고로 이 코드는 시작 위치가 항상 1이기 때문에 의도치 않게 한 바퀴를 돌 수가 있다. 하지만 어차피 목적지는 항상 우측 하단에 존재하기 때문에 시작 경로는 결과에 영향을 미치지 않는다. 그러므로 그냥 이대로 제출해도 됨.