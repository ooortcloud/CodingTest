# 00.설명

# 목차
- [00.설명](#00설명)
- [목차](#목차)
- [꼭 필요한 자료구조 기초](#꼭-필요한-자료구조-기초)
	- [스택](#스택)
	- [큐](#큐)
	- [재귀 함수(Recursive Function)](#재귀-함수recursive-function)
		- [재귀 함수의 사용처](#재귀-함수의-사용처)
		- [재귀 함수 종료 조건](#재귀-함수-종료-조건)
- [탐색 알고리즘 DFS/BFS](#탐색-알고리즘-dfsbfs)
	- [DFS(Depth-First Search)](#dfsdepth-first-search)
		- [그래프](#그래프)
		- [DFS 탐색 과정](#dfs-탐색-과정)
	- [BFS(Breadth First Search)](#bfsbreadth-first-search)
		- [BFS 탐색 과정](#bfs-탐색-과정)


# 꼭 필요한 자료구조 기초

- **탐색**
    
    **많은 양의 데이터 중에서 원하는 데이터를 찾는 과정.** 주로 그래프, 트리 등의 자료구조에서 탐색하는 문제를 다룬다. 대표적인 탐색 알고리즘이 바로 `DFS`와 `BFS`이다.
    
- **자료구조**
    
    **데이터를 표현하고 관리하고 처리하기 위한 구조.** `스택`과 `큐`는 자료구조의 대표적인 기초 개념이다. “삽입(push)”와 “삭제(pop)” 함수를 기반으로 구성이 된다. 이외에도 오버플로우와 언더플로우를 고민해야 한다. 
    

## 스택

스택은 “선입후출(FILO)” 또는 “후입선출(LIFO)” 구조이다.

파이썬에서 스택을 구현하기 위해서는 `리스트` 자료구조를 사용하면 되며, 별도의 라이브러리를 이용할 필요가 없다. append와 pop 메소드를 통해 삽입과 삭제를 구현한다.

## 큐

큐는 “선입선출(FIFO)” 구조이다.

파이썬에서 큐를 구현하기 위해서는 “collections” 모듈에서 제공하는 `deque` 자료구조를 사용하면 된다. `deque`는 데이터를 넣고 빼는 속도는 리스트에 비해 효율적이며, queue 라이브러리를 이용하는 것보다 간단히 구현할 수 있다는 장점을 갖는다. 대부분의 코딩 테스트에서는 collections 모듈과 같은 기본 라이브러리 사용을 허용하므로 마음 놓고 사용하자.

참고로, deque 객체를 list() 메소드 안에 넣어주면 deque 자료구조에서 리스트 자료구조로 변환되므로, 반드시 리스트 메소드를 사용해야 하는 경우에 잘 활용해보자.

## 재귀 함수(Recursive Function)

`재귀 함수`는 **자기 자신을 다시 호출하는 함수**이다. 

아무런 조건을 걸어두지 않으면 이론 상 무한히 호출 가능하지만, 파이썬 인터프리터에는 호출 횟수 제한이 있어 현실적으로 불가능하다. 컴퓨터 내부에서 재귀 함수 수행을 할 때 메모리 차원에서 스택 자료구조를 사용한다. 함수가 계속 호출되다가, 가장 마지막에 종료된 시점으로부터 이전의 함수들이 역으로 차례로 종료되는 구조가 딱 이 때문이다. 이렇게 재귀 함수와 스택 자료구조는 밀접한 관계를 갖다 보니, 스택 자료구조가 요구되는 대부분의 알고리즘은 재귀 함수를 활용하면 쉽게 구현할 수 있다. 후술할 DFS가 대표적인 예시이다. 

### 재귀 함수의 사용처

1. 일반적으로 큰 삼각형 안에 작은 삼각형이 있는 형태의 반복적인 형상을 띄는 문제를 풀 때 재귀 함수를 활용한다. 
2. 팩토리얼과 같이, **수학의 점화식을 그대로 소스코드로 옮겨 구현할 때 재귀 함수가 자주 활용된다.** (나중에 “다이나믹 프로그래밍”이라는 것을 통해 재귀 함수의 메모리 문제점을 극복하는 방법에 대해 다룰 것이다.)

재귀 함수에 익숙하지 않으면 구현 난이도가 높다고 생각할테지만, 재귀 함수를 잘 활용한다면 단순히 반복문을 사용하여 구현하는 것보다 훨씬 간결하게 코드를 작성할 수 있다.

### 재귀 함수 종료 조건

재귀 함수 초반 부분에는 반드시 재귀 종료 조건을 가진 조건문을 넣어줘야 한다. 그래야만 무한 반복의 굴레에서 빠져나올 수 있다.

# 탐색 알고리즘 DFS/BFS

## DFS(Depth-First Search)

**`깊이 우선 탐색`이라고 부른다. 그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘이다.** 

### 그래프

그래프는 목적지인 `노드(node)` 또는 “정점(vertex)”와, 목적지로 향하는 경로인 `간선(edge)`으로 구성되어 있다. 노드끼리는 서로 이어져 있을 수도 있고, 아닐 수도 있다. 만약 두 노드가 간선으로 이어져 있다면 “두 노드는 인접하다”고 표현한다.

“그래프 탐색”은 일반적으로 시작 노드를 기준으로 그래프의 일부 또는 전체 노드를 방문하는 것을 말한다. 

그래프는 대표적으로 2가지 방식으로 프로그래밍으로 구현할 수 있다. 

1. **인접 행렬(Adjaceney Matrix)**
    
    **`2차원 배열`에 그래프의 연결 관계를 저장하고 처리하는 방식**
    
    ![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%20a8770d07b9d04473973b37ab8ad1540c/Untitled.png)
    
    연결되어 있지 않은 노드끼리는 무한 비용으로 표현한다. (99999999 등의 값) 
    
    파이썬에서는 순수 “2차원 리스트”로 인접 행렬을 구현할 수 있다.
    
    ```python
    INF = 99999999
    
    # 각 간선의 비용을 값에 저장. 인덱스로 노드를 표현.
    graph = [
    	[0,7,5],  # 0->0, 0->1, 0->2
    	[7,0,INF],  # 1->0, 1->1, 1->2
    	[5,INF,0]  # 2->0, 2->1, 2->2
    ]
    ```
    
2. **인접 리스트(Adjaceney List)**
    
    **`리스트`에 그래프의 연결 관계를 저장하고 처리하는 방식**
    
    ![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%20a8770d07b9d04473973b37ab8ad1540c/Untitled%201.png)
    
    인접 리스트 방식에서는 모든 노드에 연결된 노드에 대한 정보를 “리스트”에 차례로 저장한다. C++나 JAVA의 경우에는 연결 리스트 구현을 위한 별도의 표준 라이브러리가 존재하지만, 파이썬에서는 리스트 자체가 기본적으로 주어지므로 그냥 리스트 쓰면 된다.
    
    파이썬에서는 “튜플”을 활용하여 “2차원 리스트”로 인접 리스트를 구현할 수 있다.
    
    ```python
    graph = [[] for _ in range(3)]
    
    # (노드, 거리) 형태로 저장
    # 노드 0
    graph[0].append((1,7))
    graph[0].append((2,5))
    # 노드 1
    graph[1].append((0,7))
    # 노드 2
    graph[2].append((0,5))
    ```
    

두 방식은 아래와 같은 차이점을 갖는다.

- 메모리 측면
    - 인접 행렬은 모든 정보를 저장해야 하므로, 메모리를 비효율적으로 낭비할 수 있다.
    - 인접 리스트는 연결 정보만 저장하면 되기 때문에 메모리를 효율적으로 사용할 수 있다.
- 연산 속도 측면
    - 인접 행렬은 테이블에서 지정된 위치의 값을 꺼내오기만 하면 되므로 빠르다.
    - 인접 리스트는 특정 노드에 대해서 깊은 탐색을 해야 하므로 느리다.

### DFS 탐색 과정

DFS는 “스택” 자료구조를 이용하며, 다음과 같이 과정을 축약할 수 있다.

1. 시작 노드를 스택에 push하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면, 해당 인접 노드를 스택에 push하고 방문 처리를 한다. (인접 노드가 여러 개라면, 관행적으로 숫자가 작은 노드부터 push한다.) 반대로 방문하지 않은 인접 노드가 없으면 최상단 노드를 스택에서 pop한다. 
3. 2번의 과정을 반복할 수 없을 때까지 반복한다.

DFS는 스택 자료구조에 기초하여 구현하므로 구현하기 쉽다. 데이터 N개 기준으로 탐색 시간은 O(N)의 시간 복잡도를 갖는다. 앞서 스택 자료구조는 “재귀 함수”를 이용하면 매우 쉽게 구현할 수 있다고 했다. 재귀 함수를 활용하여 DFS를 구현해보자.

![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%20a8770d07b9d04473973b37ab8ad1540c/Untitled%202.png)

```python
def dfs(graph, v, visited):  # (인접 리스트, 시작 노드 또는 인접 노드, 방문 리스트)
	# 해당 노드 방문 처리
	visited[v] = True
	print(v, end=' ')

	for i in graph[v]:  # 현재 노드의 인접 노드 조회
		# 인접 노드를 방문하지 않았을 때만 재귀 함수 스택의 최상단에 추가
		if not visited[i]:
			dfs(graph, i, visited)

# 인접 행렬 정의
graph = [
	[],  # 가독성을 위해 0번 인덱스는 폐기하고 1번 인덱스부터 사용
	[2,3,8],
	[1,7],
	[1,4,5],
	[3,5],
	[3,4],
	[7],
	[2,6,8],
	[1,7]
]

visited = False * 9  # 가독성을 위해 0번 인덱스는 폐기하고 1번 인덱스부터 사용

dfs(graph, 1, visited)
```

## BFS(Breadth First Search)

`**너비 우선 탐색`이라고 부른다. 인접 노드부터 탐색하는 알고리즘이다.**

최대한 멀리 있는 노드부터 조회하는 DFS와는 정반대로, 가장 가까이 있는 노드부터 조회하는 탐색 알고리즘이 BFS이다.

### BFS 탐색 과정

BFS는 “큐” 자료구조를 사용하여 구현한다. 인접한 노드를 큐에 넣으면 자연스럽게 먼저 들어온 노드가 먼저 나가기 때문에 가장 가까운 노드부터 탐색하는 형태로 구현된다.

BFS 탐색 과정은 아래와 같이 축약할 수 있다.

1. 시작 노드를 큐에 push하고 방문 처리를 한다.
2. 큐의 최하단 노드를 꺼내, 해당 노드의 인접 노드 중 방문하지 않은 모든 노드를 큐에 순차적으로 push하고 방문 처리를 한다. (관행적으로 노드 번호의 오름차순으로 큐에 push한다.)
3. 2번을 반복할 수 없을 때까지 반복한다.

BFS 역시 큐 자료구조를 바탕으로 하기 때문에 구현이 간단하다. deque 라이브러리를 사용하여 큐를 구현하는 것이 좋으며, DFS와 동일하게 탐색은 O(N) 만큼의 시간 복잡도를 갖는다. 일반적으로 deque로 구현한 BFS가 DFS보다 수행 시간이 빠르다고 한다. DFS는 재귀 함수를 사용하므로 비효율적인 연산이 일어날 수 있기 때문이다.

![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%20a8770d07b9d04473973b37ab8ad1540c/Untitled%203.png)

```python
from collections import deque

def bfs(graph, start, visited):
	# 큐 자료구조 생성
	queue = deque([start])
	# 시작 노드 방문 처리
	visited[start] = True

	while queue:
		# 최하단 노드 pop
		v = queue.popleft()
		print(v, end = ' ')
	
		for i in graph[v]:  # 현재 노드의 인접 노드 조회
			# 인접 노드를 방문하지 않았을 때만 큐의 최상단에 추가
			if not visited[i]:
				queue.append(i)
				visited[i] = True

# 인접 행렬 구현
graph = [
	[],  # 가독성을 위해 0번 인덱스는 폐기하고 1번 인덱스부터 사용
	[2,3,8],
	[1,7],
	[1,4,5],
	[3,5],
	[3,4],
	[7],
	[2,6,8],
	[1,7]
]

visited = False * 9  # 가독성을 위해 0번 인덱스는 폐기하고 1번 인덱스부터 사용

bfs(graph, 1, visited)
```

BFS는 DFS와 달리 큐를 사용하여 구현하였다. DFS에서 스택이 어디 있냐고 생각할 수 있다. **DFS의 스택은 메모리 스택이다**. 재귀 함수가 반복되면서 메모리 구조 자체에서 스택 형태를 사용하는 것이다. 그래서 DFS는 스택을 구현할 필요가 없이 재귀 함수만 구현하면 됐던 것이다. 반면 BFS의 경우에는 큐 자료구조를 직접 필드에 구현해서 사용해야 한다.

2차원 배열 탐색 문제의 경우 DFS와 BFS를 활용하여 수월하게 문제를 해결할 수 있다. 그래프 탐색 기술을 어떻게 배열에 적용할 수 있는가? 배열을 그래프로 치환하여 생각하면 된다.

![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%20a8770d07b9d04473973b37ab8ad1540c/Untitled%204.png)

3*3 형태의 2차원 배열 게임 맵이 존재한다고 하자. 각 좌표를 상하좌우로만 이동할 수 있다고 가정한다면, 각 좌표를 노드로 변형하고 이동 가능한 경로를 간선으로 표현하면 오른쪽처럼 배열을 그래프로 치환할 수 있다. 이 그래프를 인접 행렬 또는 인접 리스트로 구현한 뒤, DFS와 BFS를 적용하여 캐릭터가 움직일 수 있는 경로를 탐색하는 식으로 문제를 손쉽게 해결할 수 있다.