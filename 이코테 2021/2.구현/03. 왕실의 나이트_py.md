# 왕실의 나이트_py

## 문제 정보

행복 왕국의 왕실 정원은 체스판과 같은 8*8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서 있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다.

나이트는 말을 타고 있이 때문에 이동을 할 때에는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.

1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기

8*8 좌표 평면 상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하시오. 이때 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a부터 h로 표현한다.

예를 들어 만약 나이트가 a1에 있을 때 이동할 수 있는 경우의 수는 다음 2가지이다.

1. 오른쪽으로 두 칸 이동 후 아래로 한 칸 이동하기(c2)
2. 아래로 두 칸 이동 후 오른쪽으로 한 칸 이동하기(b3)

a1의 위치는 좌표 평면에서 구석의 위치에 해당하며 나이트는 정원의 밖으로는 나갈 수 없기 때문이다.

또 다른 예로 나이트가 c2에 위치해 있다면 나이트가 이동할 수 있는 경우의 수는 6가지이다. 이건 직접 계산해보시오.

### 문제 요약

8*8 좌표 평면 상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 8*8 좌표 평면 상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. 입력 문자는 a1처럼 열과 행으로 이뤄진다.

### 출력

- 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력하시오.

### 예제 입력 1

```python
a1
```

### 예제 출력 1

```python
2
```

## 문제의 의도

- 좌표 문제를 구현할 수 있는가?

### 아이디어

- 2차원 좌표의 이동 경우의 수를 미리 모델링해두고 반복문으로 끌어쓰자.

### 풀이

- 내 풀이

```python
point = input()
# 문자열의 각 글자는 인덱싱으로 접근 가능.
row = int(point[1])
exList = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h')
column = exList.index(point[0]) + 1  # tuple 자료구조를 활용하여 특정 값의 인덱스를 조회할 수 있음.

# 나이트의 움직임을 좌표 인터페이스로 미리 구현
moveRowList = [-2, -1, 1, 2, 2, 1, -1, -2]
moveColumnList = [1, 2, 2, 1, -1, -2, -2, -1]
# moveName = [1, 2, 4, 5, 7, 8, 10, 11]  시계 방향으로 표현하고 싶었음...

cnt = 0
for i in range(8):
    nextPointRow = row + moveRowList[i]
    nextPointColumn = column + moveColumnList[i]
    if (1 <= nextPointRow <= 8) and (1 <= nextPointColumn <= 8):
        cnt += 1

print(cnt)
```

- 교재 풀이

```python
inputData = input()
row = int(inputData[1])
column = int(ord(inputData[0])) - int(ord('a')) + 1  # String의 ord 메소드를 통해 사전식 순서 비교 가능.

# 나이트의 이동 방향을 각각 튜플 형태로 좌표를 구상하고 리스트에 저장.
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]  #(drow, dcolumn)

cnt = 0
for step in steps:
    nextRow = row + step[0]
    nextColumn = column + step[1]
    if 1 <= nextRow and nextRow <= 8 and 1 <= nextColumn and nextColumn <= 8:
        cnt += 1

print(cnt)
```

`ord` 메소드를 활용하여 알파벳 순으로 숫자 차이를 비교하는 방법은 알파벳들을 숫자로 치환할 때 매우 유용해 보인다. 그리고 나이트의 이동 방향은 고정되어 있으므로, 튜플 자료구조를 통해 가시적으로 이동 좌표를 표현하는 방법이 좋아 보인다. 이렇게 하면 range를 사용해서 인덱스를 추출하는 원시적인 방식에서 벗어나, 리스트에서 좌표값 자체를 뽑아올 수 있다보니 반복문을 컨트롤하기 더 편해진다.