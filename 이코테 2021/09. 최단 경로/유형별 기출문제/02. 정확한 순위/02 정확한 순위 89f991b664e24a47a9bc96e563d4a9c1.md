# 02. 정확한 순위

## 문제 정보

선생님은 시험을 본 학생 n명의 성적을 분실하고, 성적을 비교한 결과의 일부만 갖고 있다. 학생 n명의 성적은 모두 다른데, 다음은 6명의 학생에 대해 6번만 성적을 비교한 결과이다.

- 1번 학생의 성적 < 5번 학생의 성적
- 3번 학생의 성적 < 4번 학생의 성적
- 4번 학생의 성적 < 2번 학생의 성적
- 4번 학생의 성적 < 6번 학생의 성적
- 5번 학생의 성적 < 2번 학생의 성적
- 5번 학생의 성적 < 4번 학생의 성적

a번 학생의 성적이 b번 학생보다 낮다면 화살표가 a에서 b를 가리키도록 할 때 위의 성적 결과를 다음 그림처럼 표현할 수 있다.

![Untitled](02%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B1%2089f991b664e24a47a9bc96e563d4a9c1/Untitled.png)

이 그림으로 유추해서 순위를 정확히 알 수 있는 학생도 있고, 그렇지 않은 학생도 있다. 예를 들어 1번 학생은 5번 학생보다 성적이 낮고, 5번 학생은 4번 학생보다 성적이 낮으므로, 1번 학생은 4번 학생보다 성적이 낮다. 따라서 1, 3, 5번 학생은 모두 4번 학생보다 성적이 낮다고 볼 수 있다. 그리고 4번 학생은 2번, 6번 학생보다 성적이 낮다. 그러므로 4번 학생은 3등일 것이라고 추측할 수 있다. 하지만 4번 학생을 제외한 다른 학생의 정확한 순위는 이대로는 파악할 수 없다.

학생들의 성적을 비교한 결과가 주어질 때, 성적 순위를 정확히 알 수 있는 학생은 모두 몇 명인지 계산하는 프로그램을 작성하라.

### 문제 요약

성적 순위를 정확히 알 수 있는 학생은 모두 몇 명인지 계산하는 프로그램을 작성하라.

### 입력

- 첫째 줄에 학생들의 수 n(2 이상 500 이하)과 두 학생의 성적을 비교한 횟수 m(2 이상 10000 이하)이 주어진다.
- 다음 m개의 각 중에는 두 학생의 성적을 비교한 결과를 나타내는 두 양의 정수 a와 b가 주어진다. 이는 a번 학생의 성적이 b번 학생보다 낮다는 것을 의미한다.

### 출력

- 첫째 줄에 성적 순위를 정확히 알 수 있는 학생이 몇 명인지 출력하라.

### 예제 입력 1

```python
6 6
1 5
3 4
4 2
4 6
5 2
5 4
```

### 예제 출력 1

```python
1
```

## 문제의 의도

- 주어진 문제를 그래프 형태로 해석할 수 있는가?
- 그래프 문제가 주어졌을 때 최단 경로 알고리즘을 적용할 수 있는가?

### 아이디어

전혀 모르겠다.

## 풀이

### 답안 풀이

위 문제의 예시처럼, 성적이 낮은 학생이 성적이 높은 학생을 가리키는 방향으로 방향 그래프를 구현할 수 있으므로, 학생들의 성적을 비교한 결과를 그래프로 표현이 가능하다. 이 말은 곧, 위 문제에 최단 경로 알고리즘을 적용할 수 있다는 것인데, 어떻게 최단 경로 알고리즘으로 성적 순위를 정확히 알 수 있는 지 알아낼 수 있단 말인가?

**두 학생의 성적을 비교할 때마다 경로가 형성된다. 다시 말해 두 학생 사이에 경로가 형성되어 있다면, 두 학생은 서로 성적을 비교할 수 있다는 것이다.** 반대로 두 학생 사이에 경로가 형성되어 있지 않으면 성적 비교 결과를 알 수 없는 사이가 된다.

이 문제는 전체 경로 탐색 문제로 변형하여 생각해볼 수 있으니 플로이드 알고리즘을 적용하는 것이 좋겠다. 전제 조건에서 학생 수가 500명을 넘지 않으므로, 플로이드 알고리즘을 적용해도 시간 초과가 발생할 일이 없다. 

```python
import sys
input = sys.stdin.readline
INFINITY = int(1e9)
PATH_EXIST = 1

n, m = map(int, input().split())
graph_or_distanceTbl = [[INFINITY] * (n+1) for _ in range(n+1)]

for src in range(1, n+1):
    for dst in range(1, n+1):
        if src == dst:
            graph_or_distanceTbl[src][dst] = 0

for _ in range(m):
    lowerStudent, higherStudent = map(int, input().split())
    graph_or_distanceTbl[lowerStudent][higherStudent] = PATH_EXIST  # 경로가 형성되어 있다는 것만 표현하면 됨.

for k in range(1, n+1):
    for src in range(1, n+1):
        for dst in range(1, n+1):
            graph_or_distanceTbl[src][dst] = min(graph_or_distanceTbl[src][dst],
                                                 graph_or_distanceTbl[src][k] + graph_or_distanceTbl[k][dst])
            
cnt = 0
for src in range(1, n+1):
    check = 0  # src -> dst 경로 개수 체크
    for dst in range(1, n+1):
        # 단방향 경로이므로 양쪽 모두 체크해줘야 한다.
        if graph_or_distanceTbl[src][dst] != INFINITY or graph_or_distanceTbl[dst][src] != INFINITY:
            check += 1
    
    # 해당 src가 모든 dst로 갈 수 있는 경로를 보유하고 있다면, 해당 src의 순위를 구할 수 있다.
    if check == n:
        cnt += 1

print(cnt)
```

이번 문제는 비교 관계를 통해 경로를 형성할 수 있는 상태에서 문제가 주어졌을 때 그래프의 실용성을 확인할 수 있는 문제였다. 이전에는 단순 대소 비교가 뭐 대수라고 생각했었다면, 이제는 대소 비교가 가능하다면 경로를 형성할 수 있다는 의미이므로 그래프 알고리즘을 적용할 수 있겠구나 하는 생각이 든다. 위 문제처럼 한 눈에 안 들어오는 복잡한 대소 비교 관계는 실생활에서 자주 마주할 수 있는 문제이므로, 진정한 프로그래머가 되기 위해서는 그래프 알고리즘 학습은 선택이 아닌 필수라고 할 수 있다.