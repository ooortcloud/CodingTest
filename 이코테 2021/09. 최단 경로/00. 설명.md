# 00. 설명

# 목차

- [00. 설명](#00-설명)
- [목차](#목차)
- [가장 빠르게 도달하는 방법](#가장-빠르게-도달하는-방법)
- [다익스트라 최단 경로 알고리즘](#다익스트라-최단-경로-알고리즘)
  - [구현하기 쉽지만 비효율적인 다익스트라 알고리즘 구현 코드](#구현하기-쉽지만-비효율적인-다익스트라-알고리즘-구현-코드)
    - [예제 코드](#예제-코드)
  - [구현하기 까다로우나 효율적으로 동작하는 다익스트라 알고리즘 구현 코드](#구현하기-까다로우나-효율적으로-동작하는-다익스트라-알고리즘-구현-코드)
    - [힙(Heap)과 우선순위 큐(Priority Queue)](#힙heap과-우선순위-큐priority-queue)
    - [우선순위 큐 종류](#우선순위-큐-종류)
    - [예제 코드(개선 후)](#예제-코드개선-후)
    - [예제 입력](#예제-입력)
    - [예제 출력](#예제-출력)
- [플로이드 워셜 알고리즘](#플로이드-워셜-알고리즘)
    - [예제 코드](#예제-코드-1)
    - [예제 입력](#예제-입력-1)
    - [예제 출력](#예제-출력-1)
- [그래서 언제 쓰는가?](#그래서-언제-쓰는가)
  - [다익스트라 최단 경로 알고리즘](#다익스트라-최단-경로-알고리즘-1)
  - [플로이드 알고리즘](#플로이드-알고리즘)



# 가장 빠르게 도달하는 방법

`최단경로` 알고리즘은 가장 짧은 경로를 찾는 알고리즘이다. 가장 빠른 길 찾기 문제와 일맥상통한다. 최단 경로 문제는 보통 그래프를 이용하여 표현한다. 각각의 지점은 그래프의 “노드”, 그리고 연결된 도로를 그래프의 “간선”으로 표현한다. 

최단 경로 알고리즘은 수많은 알고리즘이 있으며, 이미 상황에 맞는 효율적인 최단경로 알고리즘이 정립되어 있다. 코딩 테스트에서 자주 등장하는 최단 경로 알고리즘은 `다익스트라 최단 경로 알고리즘`, `플로이드 워셜` 이렇게 두 가지이다. 그러니 이 둘만 확실히 배워도 최단 경로 알고리즘을 풀어낼 수 있을 것이다.

# 다익스트라 최단 경로 알고리즘

`다익스트라 최단 경로 알고리즘(이하 다익스트라 알고리즘)`은 그래프 상에서 여러 노드들이 있을 때, 어떤 노드에서 출발하여 다른 노드로 가는 경우에 대한 각각의 모든 최단 경로를 구하는 알고리즘이다. 이 알고리즘은 음의 비용을 갖는 간선이 없을 때만 사용 가능하다. 허나 현실 세계 에서는 음의 비용을 갖는 간선을 표현할 일이 거의 없어서 주로 기본 알고리즘으로 채택한다.

다익스트라 알고리즘은 사실 그리디 알고리즘의 한 유형이다. 왜냐하면 매번 가장 비용이 적은 노드를 선택해서 탐색을 반복하기 때문이다.

1. 출발 노드를 설정
2. 최단 거리 테이블 초기화(1차원 리스트로 구현)
3. 방문하지 않은 노드 중 가장 짧은 노드를 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하며, 만약 그 경로가 더 빠른 경로인 경우 최단 거리 테이블을 갱신
5. 모든 노드에 대해 탐색될 때까지 3~4번 무한 반복

## 구현하기 쉽지만 비효율적인 다익스트라 알고리즘 구현 코드

간단한 다익스트라 알고리즘의 시간복잡도는 $O(V^{2})$이다.(V는 노드의 개수) 매번 알고리즘을 반복할 때마다 “방문하지 않은 노드 중에서 가장 빠른 노드를 선택”하기 위해, 각 노드마다 최단 거리 테이블을 순차탐색해야 하기 때문이다. 그래서 노드의 개수가 10000개를 넘어가면 아래 코드로는 문제를 풀기 어렵다… 그렇지만 일단 다익스트라 알고리즘 이해를 위해 알아보자.

### 예제 코드

참고로 코딩 테스트 문제에서는 대부분 최단 거리 테이블 출력만 요구하기 때문에, 이번 장에서는 최단 경로 출력을 구현하는 코드는 만나볼 수 없다. 하지만 제시된 코드를 조금만 변형하면 되기 때문에 추가적으로 구현하기 어렵지는 않을 것이다.

```python
import sys
input = sys.stdin.readline
INFINITY = int(1e9)

n, m = map(int, input().split())
startNode = int(input())
graph = [[] for _ in range(n+1)]  # 주어진 그래프를 기록하는 리스트
distanceTbl = [INFINITY] * (n+1)  # 시작 노드로부터 해당 노드까지 최단 거리를 기록하는 테이블
visitedTbl = [False] * (n+1)  # 해당 노드에 방문한 적이 있는지 기록하는 테이블

for _ in range(m):
    src, dst, cost = map(int, input().split())
    graph[src].append((dst, cost))  # 인덱스 : 출발 노드, 값 : tuple(도착 노드, src -> dst 비용)

def getSmallestNode():
    minVal = INFINITY
    smallestNode = 0
    for getNodeNum in range(1, n+1):  # 순차탐색
        if distanceTbl[getNodeNum] < minVal and not visitedTbl[getNodeNum]:
            minVal = distanceTbl[getNodeNum]
            smallestNode = getNodeNum
    return smallestNode

def dijkstra(startNode):
    # 시작 노드 탐색
    distanceTbl[startNode] = 0
    visitedTbl[startNode] = True
    for dst, cost in graph[startNode]:
        distanceTbl[dst] = cost
    
    for _ in range(n-1):  # 시작노드 제외하고 탐색 진행
        src = getSmallestNode()  # 다음 탐색 노드 선정(비용이 적은 순)
        visitedTbl[src] = True

        for dst, cost in graph[src]:
            newCost = distanceTbl[src] + cost
            if newCost < distanceTbl[dst]:  # 기존 경로보다 신규 경로가 더 저렴하면 테이블을 갱신
                distanceTbl[dst] = newCost

dijkstra(startNode)

for getNodeNum in range(1, n+1):
    if distanceTbl[getNodeNum] == INFINITY:
        print("INFINITY")
    else:
        print(distanceTbl[getNodeNum])
```

- 입력되는 데이터 수가 많다는 가정 하에 “input”을 `sys.stdin.readline`으로 치환하였다.
- 인덱스 번호를 노드 번호로 사용하기 위해 리스트의 크기를 “노드의 개수 + 1”만큼 배정하였다. 이 방식은 그래프를 다루는 문제에서 흔히 사용되기 때문에 꼭 숙지하자.

## 구현하기 까다로우나 효율적으로 동작하는 다익스트라 알고리즘 구현 코드

코딩 테스트를 준비하는 입장에서는 반드시 이 코드를 정확히 이해하고 구현할 수 있어야 한다. 이를 이해하면 비단 최단 경로 알고리즘 뿐만 아니라 다양한 고난이도 문제를 만났을 때에도 도움을 얻을 수 있다.

개선된 다익스트라 알고리즘의 시간 복잡도는 $O(ElogV)$를 보장한다. 기존에는 최단 거리가 가장 짧은 노드를 리스트 상에서 순차탐색을 하여 발견했다. 하지만 **개선된 다익스트라 알고리즘은 `힙 자료구조`를 사용하여 `우선순위 큐` 를 통해 가장 짧은 노드를 찾아낸다.**

### 힙(Heap)과 우선순위 큐(Priority Queue)

`힙 자료구조`는 우선순위 큐를 구현하기 위해 사용하는 자료구조 중 하나다. 그리고 `우선순위 큐`는 우선순위가 가장 높은 데이터를 가장 먼저 pop시킨다는 것이 핵심 특징이다. 

대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리를 제공한다. 그래서 일반적인 코딩 테스트 환경에서는 우선순위 큐를 구현할 필요는 없다. 파이썬에서는 `heapq` 라이브러리에서 제공하는 우선순위 큐 라이브러리를 쓰는 것이 가장 좋다.

**우선순위 큐는 push할 때마다 항상 우선순위가 높은 데이터가 앞에 오도록 정렬한다. 그래서 우선순위 큐에서는 항상 우선순위가 높은 데이터부터 pop된다.** 예컨데, (가치, 물건) 형태의 데이터를 우선순위 큐에 저장하여 가치에 우선순위를 부여하여 pop을 시키면 가장 가치가 높은 물건 데이터가 먼저 튀어나온다. 대부분의 프로그래밍 언어에서는 첫 번째 원소를 우선순위 기준으로 삼으며, 파이썬도 그러하다.

### 우선순위 큐 종류

우선순위 큐에는 두 가지 종류가 있다.

- 최소 힙 : 우선순위 대상 데이터 값이 작은 데이터를 먼저 pop　(1 → 2 → 3 → …)
- 최대 힙 : 우선순위 대상 데이터 값이 큰 데이터를 먼저 pop　(100 → 99 → 98 → …)

파이썬 라이브러리의 우선순위 큐는 `최소 힙`으로 구현되어 있다. 다익스트라 알고리즘의 경우 비용이 적은 순으로 탐색을 하므로, 파이썬에서 제공하는 우선순위 큐를 그대로 사용하여 다익스트라 알고리즘을 구현하면 된다. 

만약 문제를 풀기 위해서 최대 힙을 구현해야 한다면, 우선순위에 해당하는 값에 “음수 부호”를 붙여 저장한 뒤, 나중에 값을 꺼내어 출력할 때 다시 “음수 부호”를 곱하여 원래 값을 출력하도록 꼼수를 부릴 수 있다. 이 테크닉은 코딩 테스트에서 빈번히 쓸 수 있으므로 기억해두자.

참고로, 우선순위 큐를 구현할 때 힙 자료구조가 아닌 리스트를 사용해서도 구현할 수 있다. 그러나 리스트에서 값을 pop할 때마다 리스트 내 모든 원소를 순차탐색해서 가장 큰 우선순위 데이터를 찾아내야 하므로, 최악의 경우 시간복잡도 $O(N)$을 갖는다. 반면 힙으로 구현하면 시간복잡도 $O(logN)$을 갖기 때문에, 데이터 개수가 많아질수록 힙 자료구조로 구현된 우선순위 큐의 성능이 월등히 높아진다.

아무튼 핵심 내용을 요약해보자. 

1. 이전 다익스트라 알고리즘은 일차원 리스트에 가장 가까운 노드를 저장했다. 그래서 만약 대량의 데이터가 입력되면, 제한 시간 내에 최단 거리 탐색을 수행해내지 못한다.
2. 반면 이번 개선된 다익스트라 알고리즘은 힙 자료구조로 구현된 우선순위 큐를 활용해 가장 가까운 노드를 저장한다. 여기서 성능 차이가 발생하는 것이다.

### 예제 코드(개선 후)

```python
import heapq
import sys
input = sys.stdin.readline
INFINITY = int(1e9)
startCost = 0

n, m = map(int, input().split())
startNode = int(input())
graph = [[] for _ in range(n+1)]
distanceTbl = [INFINITY] * (n+1)

for _ in range(m):
    src, dst, cost = map(int, input().split())
    graph[src].append((dst, cost))

def dijkstra(startNode):
    q = list()
    heapq.heappush(q, (startCost, startNode))  # 일반 리스트에 우선순위 큐처럼 데이터를 push하는 라이브러리 기능. push할 때 맨 앞 요소를 기준으로 정렬됨.
    distanceTbl[startNode] = startCost

    while q:
        newCost, src = heapq.heappop(q)  # 일반 리스트에서 우선순위 큐처럼 데이터를 pop하는 라이브러리 기능

        if distanceTbl[src] < newCost:  # 기존보다 더 저렴하거나 같은 경우에만 최단 경로 탐색 진행 허용
            continue
        for dst, cost in graph[src]:
            newCost = distanceTbl[src] + cost
            if newCost < distanceTbl[dst]:  # 기존 경로보다 신규 경로가 더 저렴하면 최단  경로 테이블을 갱신
                distanceTbl[dst] = newCost
                heapq.heappush(q, (newCost, dst))  # 우선순위 큐에 기존보다 더 저렴한 경로로 가는 데이터를 push
        

dijkstra(startNode)

for getNode in range(1, n+1):
    if distanceTbl[getNode] == INFINITY:
        print("INFINITY")
    else:
        print(distanceTbl[getNode])
```

- 우선순위 큐의 성질 덕분에, 위 코드 상에서 한 번 처리된 노드는 다시 처리할 일이 생기지 않는다. 매번 push할 때마다 우선순위가 높은 애들이 항상 앞에 오도록 정렬되고, 그래서 비용이 낮은 애들이 항상 앞에서 pop되어 최단거리 테이블을 마감시키기 때문이다. 그러므로 방문 테이블을 구현할 필요가 없다.
    
    결과적으로 반복문에서 노드를 탐색하는 횟수는 노드의 개수 V 만큼이며, 각 탐색마다 해당 노드 자신과 연결된 간선들의 비용을 모두 확인하기 때문에 간선의 개수 E만큼 추가적인 연산이 들어간다.
    
- 우선순위 큐에 의해 다익스트라 알고리즘의 시간 복잡도는 $O(ElogV)$가 된다… 물론 직접 우선순위 큐를 구현하지는 않았으니 당장은 이해하기 어렵겠지만, 일단 위 코드를 숙지하는 것은 필수다. 깊은 이해가 필요하다면 구글링 ㄱㄱ.
- 이 코드는 단순히 최소 비용을 구하는 코드이다. 만약 최단 경로를 구하는 코드라고 생각하며 접근한다면 위 코드가 명확히 이해가 가지 않을 것이다.

### 예제 입력

```python
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
```

### 예제 출력

```python
0
2
3
1
2
4
```

다익스트라 알고리즘은 우선순위 큐를 이용하기 때문에, 우선순위 큐를 요구하는 다른 고급 문제들을 푸는 데에도 큰 도움을 준다. 그러니 다익스트라 알고리즘을 완벽히 이해할 수 있을 때까지 학습하는 것이 좋다.

# 플로이드 워셜 알고리즘

다익스트라 알고리즘의 경우 “한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 경우”에 사용했다. 반복 단계마다 최단 거리를 갖는 노드를 하나씩 선택하고, 해당 노드를 거쳐가는 경로를 확인하여 최단 거리 테이블을 갱신하며 최단 거리를 찾아낸다.

반면 `플로이드 워셜 알고리즘`은 “모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 경우”에 사용하는 알고리즘이다. 다익스트라 알고리즘과는 다르게 방문한 노드를 재방문하여 전체 탐색을 하는 것이 가장 큰 차이점이다. 노드의 개수가 N개일 때, 알고리즘을  N번 반복하여 $O(N^{2})$의 연산을 하여 현재 노드를 거쳐가는 모든 경로를 전부 고려한다. 그래서 플로이드 워셜 알고리즘의 시간복잡도는 $O(N^{3})$이 된다.

다익스트라 알고리즘은 1차원 리스트를 사용하여 최단 거리 테이블을 구현했다. 하지만 플로이드 위셜 알고리즘은 2차원 리스트를 최단 거리 테이블로 사용한다. 그래야 모든 노드에 대해 다른 모든 경로에 대한 최단 거리 정보를 저장할 수 있기 때문이다. (주로 행쪽을 src, 열쪽을 dst로 두어 저장)

다익스트라 알고리즘은 매 반복마다 가장 비용이 적은 노드를 선택해서 탐색을 반복하는 “그리디 알고리즘”으로 진행되었다. 반면 플로이드 위셜 알고리즘은 노드 개수 N번 만큼의 단계를 반복하여 점화식에 맞게 2차원 리스트인 최단 거리 테이블을 갱신하기 때문에 “다이나믹 프로그래밍”으로 볼 수 있다.

플로이드 위셜 알고리즘의 점화식은 아래와 같다.

$D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$

위 점화식은 두 비용 중, 더 작은 값을 a(src)에서 b(dst)로 가는 최소 비용으로 결정한다.

- a에서 b로 가는 최소 비용
- a에서 k를 거쳐 b로 가는 최소 비용

이는 3중 반복문을 활용해 쉽게 구현할 수 있다.

### 예제 코드

```python
INFINITY = int(1e9)

n = int(input())
m = int(input())
graph_or_distanceTbl = [[INFINITY] * (n+1) for _ in range(n+1)]  # 2차원 리스트의 그래프이자 최단 거리 테이블 생성

for src in range(1, n+1):
    for dst in range(1, n+1):
        if src == dst:
            graph_or_distanceTbl[src][dst] = 0

for _ in range(m):
    src, dst, cost = map(int, input().split())
    graph_or_distanceTbl[src][dst] = cost

for k in range(1, n+1):
    for src in range(1, n+1):
        for dst in range(1, n+1):
            graph_or_distanceTbl[src][dst] = min(graph_or_distanceTbl[src][dst], graph_or_distanceTbl[src][k] + graph_or_distanceTbl[k][dst])  # 점화식

for src in range(1, n+1):
    for dst in range(1, n+1):
        if graph_or_distanceTbl[src][dst] == INFINITY:
            print("INFINITY", end=" ")
        else:
            print(graph_or_distanceTbl[src][dst], end=" ")
    print()  # src 바뀔 때마다 줄바꿈
```

- 플로이드 위셜 알고리즘을 구현할 때는 그래프와 최소 거리 테이블을 동일시한다.
- 자기 자신에게 가는 비용은 항상 0이다. 그래서 최소 거리 테이블 상에서 왼쪽 위에서 오른쪽 아래로 내려가는 대각 방향의 모든 값은 전부 0이 된다.
- 점화식을 사용하여 그래프 내 전체 경우의 수에 대한 최단 거리를 구한다.

### 예제 입력

```python
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
```

### 예제 출력

```python
0 4 8 6
3 0 7 9
5 9 0 4
7 11 2 0
```

# 그래서 언제 쓰는가?

## 다익스트라 최단 경로 알고리즘

**다익스트라 알고리즘은 한 노드에서 다른 노드로 가는 최단 경로를 찾는 데 사용된다.**

- 두 도시 사이의 최단 거리 구하기
- 지도가 주어졌을 때, 출발지에서 목적지까지의 최단 경로 구하기
- 네비게이션
- 라우팅
- 최소 비용 경로 구하기

## 플로이드 알고리즘

**플로이드 알고리즘은 모든 노드 간의 최단 경로를 찾는 데 사용된다.**

- 어떤 네트워크에서 모든 노드 간의 최단 경로 구하기
- 제조 공정에서 모든 공정 간의 최단 경로 구하기
- 네트워크 흐름 제어
- 최적화 문제 해결
- 사회적 네트워크 분석

다만 플로이드 알고리즘은 연산 속도가 너무 느리기 때문에, 주어진 노드가 1000개를 넘어가면 제한 시간(1~2초) 내에 문제 해결이 불가능하다.