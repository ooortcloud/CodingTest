`최단경로` 알고리즘은 가장 짧은 경로를 찾는 알고리즘이다. 가장 빠른 길 찾기 문제와 일맥상통한다. 최단 경로 문제는 보통 그래프를 이용하여 표현한다. 각각의 지점은 그래프의 `노드`, 그리고 연결된 도로를 그래프의 `간선`으로 표현한다. 최단 경로 알고리즘은 수많은 알고리즘이 있으며, 이미 상황에 맞는 효율적인 최단경로 알고리즘이 정립되어 있다. 그 중 코딩 테스트에서 자주 등장하는 최단 경로 알고리즘은 `다익스트라 최단 경로 알고리즘`, `플로이드 워셜` 이렇게 두 가지이다. 코딩 테스트에서는 경로를 모두 출력하기 보다는, 가장 짧은 경로의 총 비용을 출력하는 문제가 주로 출제된다.

참고로 최단경로 알고리즘은 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 그대로 적용된다. 즉, 최단 경로 문제는 그리디 알고리즘 또는 다이나믹 프로그래밍의 한 종류이다.

# 다익스트라 최단 경로 알고리즘

`다익스트라 최단 경로 알고리즘(이하 다익스트라 알고리즘)`은 그래프 상에서 여러 노드들이 있을 때, 어떤 노드에서 출발하여 다른 노드로 가는 경우에 대한 각각의 모든 최단 경로를 구하는 알고리즘이다. 그러니까, 한 지점을 고정한 상태에서 다른 특정 지점까지의 최단경로를 구하는 알고리즘이다. 이 알고리즘은 **음의 비용을 갖는 간선이 없을 때만 사용 가능**하다. 허나 현실 세계 에서는 음의 비용을 갖는 간선을 표현할 일이 거의 없어서 주로 기본 알고리즘으로 채택한다. (GPS 등) 다익스트라 알고리즘은 사실 그리디 알고리즘의 한 유형이다. 왜냐하면 매번 가장 비용이 적은 노드를 선택해서 탐색을 반복하기 때문이다.

## 이론 설명
### 동작 원리
1. **시작 정점 선택**: 알고리즘은 특정한 시작 정점에서 시작합니다.
2. **가중치 초기화**: 각 정점까지의 거리를 무한대(∞)로 설정하고, 시작 정점의 거리는 0으로 설정합니다. 최단 거리 테이블을 초기화한다. (1차원 리스트로 구현)
3. **방문한 정점 처리**: 방문한 적이 없는 정점 중에서, 현재까지 가장 짧은 경로를 가진 정점을 선택하고 그 정점을 처리합니다.
4. **인접한 정점 업데이트**: 해당 정점에서 인접한 정점들까지의 거리를 계산하여 더 짧은 경로가 있으면 그 경로로 업데이트합니다.
5. **반복**: 모든 정점을 방문할 때까지 위 과정을 반복합니다.

하나의 노드를 선택할 때마다, 그 노드에 대한 최단거리를 확실히 찾게 된다는 특징이 있다.

### 알고리즘의 구체적인 단계
1. **초기화**:
   - 시작 정점은 거리를 0으로 설정하고, 나머지 정점은 거리를 ∞로 설정.
   - 시작 정점부터 탐색을 시작.

2. **현재 정점 선택**:
   - 아직 방문하지 않은 정점들 중에서 거리가 가장 짧은 정점을 선택.

3. **인접 정점 업데이트**:
   - 현재 정점과 인접한 정점들의 거리를 확인.
   - 만약, 현재 정점을 통해 가는 경로가 더 짧다면, 그 정점의 거리를 갱신.

4. **반복**:
   - 모든 정점을 방문할 때까지 위 과정을 반복.

### 시간 복잡도
다익스트라 알고리즘의 시간 복잡도는 구현 방식에 따라 달라집니다. 
- 우선순위 큐를 사용하지 않으면 \(O(V^2)\) (V는 정점의 개수) 
- **우선순위 큐**(힙)을 사용하면 \(O((V + E) \log V)\) (E는 간선의 개수) 정도의 시간 복잡도를 가집니다.

참고로, 시험을 준비하는 사람들은 두 번째 방식을 완벽히 암기하고 있어야 한다. 주로 출제되는 유형이기도 하고, 여기서 영감을 얻을 수 있는 것들이 많기 때문이다.

### 장점과 단점
- **장점**: 모든 정점에 대해 최단 경로를 찾을 수 있고, 음수가 아닌 가중치를 가진 그래프에서 매우 효율적입니다.
- **단점**: 가중치가 음수인 그래프에서는 동작하지 않으며, 그런 경우에는 벨만-포드 알고리즘 등을 사용해야 합니다.

### 예시
그래프가 아래와 같다고 가정해 봅시다:
- A → B (비용: 1)
- A → C (비용: 4)
- B → C (비용: 2)
- B → D (비용: 6)
- C → D (비용: 3)

1. A에서 출발:
   - A → B: 1
   - A → C: 4
2. B를 경유하여 C에 도달할 수 있는 경로를 갱신:
   - A → B → C: 1 + 2 = 3
3. 마찬가지로 D까지 최단 경로를 갱신:
   - A → B → C → D: 1 + 2 + 3 = 6

이와 같은 방식으로 모든 정점에 대한 최단 경로를 구할 수 있습니다.


## 구현하기 쉽지만 비효율적인 다익스트라 알고리즘 구현 코드

간단한 다익스트라 알고리즘의 시간복잡도는 $O(V^{2})$이다.(V는 노드의 개수) 매번 알고리즘을 반복할 때마다 “방문하지 않은 노드 중에서 가장 빠른 노드를 선택”하기 위해, 각 노드마다 최단 거리 테이블을 순차탐색해야 하기 때문이다. 노드의 개수가 10000개를 넘어가면 아래 코드로는 시간 제한 내로 문제를 풀기 어렵다…

### 예제 코드

참고로 코딩 테스트 문제에서는 대부분 최단 거리 테이블 출력만 요구하기 때문에, 이번 장에서는 최단 경로 자체를 출력을 구현하는 예제 코드는 만나볼 수 없다. 하지만 제시된 코드를 조금만 변형하면 되기 때문에 추가적으로 구현하기 어렵지는 않을 것이다.

```python
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
# 시작 노드 번호를 입력받기
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]
# 방문한 적이 있는지 체크하는 목적의 리스트를 만들기
visited = [False] * (n + 1)
# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기
for _ in range(m):
    src, dst, val = map(int, input().split())
    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[src].append((dst, val))

# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node():
    min_value = INF
    index = 0 # 가장 최단 거리가 짧은 노드(인덱스)
    for i in range(1, n + 1):
        if not visited[i] and distance[i] < min_value:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    # 시작 노드에 대해서 초기화
    distance[start] = 0
    visited[start] = True
    for dst, val in graph[start]:
        distance[dst] = val
        
    # 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
    for _ in range(n - 1):
        # 현재 최단 거리가 가장 짧은 노드를 꺼내고 방문 처리
        now = get_smallest_node()
        visited[now] = True
        # 현재 노드와 연결된 다른 노드를 확인
        for dst, val in graph[now]:
            crossCost = distance[now] + val
            # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if crossCost < distance[dst]:
                distance[dst] = crossCost

# 다익스트라 알고리즘을 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    # 도달할 수 있는 경우 거리를 출력
    else:
        print(distance[i])
```

- 입력되는 데이터 수가 많다는 가정 하에 “input”을 `sys.stdin.readline`으로 치환하였다.
- 인덱스 번호를 노드 번호로 사용하기 위해 리스트의 크기를 “노드의 개수 + 1”만큼 배정하였다. 이 방식은 그래프를 다루는 문제에서 흔히 사용되기 때문에 꼭 숙지하자.

```java
import java.util.*;

class Node {

    private int index;
    private int distance;

    public Node(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    public int getIndex() {
        return this.index;
    }

    public int getDistance() {
        return this.distance;
    }
}

public class Main {

    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정
    // 노드의 개수(N), 간선의 개수(M), 시작 노드 번호(Start)
    // 노드의 개수는 최대 100,000개라고 가정
    public static int n, m, start;
    // 각 노드에 연결되어 있는 노드에 대한 정보를 담는 배열
    public static ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();
    // 방문한 적이 있는지 체크하는 목적의 배열 만들기
    public static boolean[] visited = new boolean[100001];
    // 최단 거리 테이블 만들기
    public static int[] d = new int[100001];

    // 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
    public static int getSmallestNode() {
        int min_value = INF;
        int index = 0; // 가장 최단 거리가 짧은 노드(인덱스)
        for (int i = 1; i <= n; i++) {
            if (d[i] < min_value && !visited[i]) {
                min_value = d[i];
                index = i;
            }
        }
        return index;
    }

    public static void dijkstra(int start) {
        // 시작 노드에 대해서 초기화
        d[start] = 0;
        visited[start] = true;
        for (Node node : graph.get(start)) {
            d[node.getIndex()] = node.getDistance();
        }
        // 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
        for (int i = 0; i < n - 1; i++) {
            // 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
            int now = getSmallestNode();
            visited[now] = true;
            // 현재 노드와 연결된 다른 노드를 확인
            for (Node node : graph.get(now)) {
                int cost = d[now] + node.getDistance();
                // 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
                if (cost < d[node.getIndex()]) {
                    d[node.getIndex()] = cost;
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        m = sc.nextInt();
        start = sc.nextInt();

        // 그래프 초기화
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<Node>());
        }

        // 모든 간선 정보를 입력받기
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            // a번 노드에서 b번 노드로 가는 비용이 c라는 의미
            graph.get(a).add(new Node(b, c));
        }

        // 최단 거리 테이블을 모두 무한으로 초기화
        Arrays.fill(d, INF);
        
        // 다익스트라 알고리즘을 수행
        dijkstra(start);

        // 모든 노드로 가기 위한 최단 거리를 출력
        for (int i = 1; i <= n; i++) {
            // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
            if (d[i] == INF) {
                System.out.println("INFINITY");
            }
            // 도달할 수 있는 경우 거리를 출력
            else {
                System.out.println(d[i]);
            }
        }
    }
}
```


### 예제 입력

```
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
```

### 예제 출력

```
0
2
3
1
2
4
```

## 구현하기 까다로우나 효율적으로 동작하는 다익스트라 알고리즘 구현 코드

코딩 테스트를 준비하는 입장에서는 반드시 이 코드를 정확히 이해하고 구현할 수 있어야 한다. 이를 이해하면 비단 최단 경로 알고리즘 뿐만 아니라 다양한 고난이도 문제를 만났을 때에도 도움을 얻을 수 있다.

개선된 다익스트라 알고리즘의 시간 복잡도는 $O(ElogV)$를 보장한다. 기존에는 최단 거리가 가장 짧은 노드를 리스트 상에서 순차탐색을 하여 발견하는 것이 성능을 나쁘게 만들었다. 하지만 **개선된 다익스트라 알고리즘은 `힙 자료구조`를 사용하여 `우선순위 큐` 를 통해 가장 짧은 노드를 찾아낸다.**

### 힙이란?

힙은 완전 이진 트리(Complete Binary Tree)의 특성을 가지면서, 부모 노드와 자식 노드 간에 특정한 관계를 만족하는 자료구조입니다. 힙은 우선순위 큐를 구현하는 데 주로 사용되며, 최대 힙(Max Heap)과 최소 힙(Min Heap) 두 가지 종류가 있습니다.

* **최대 힙:** 부모 노드의 값이 자식 노드의 값보다 항상 크거나 같은 힙
* **최소 힙:** 부모 노드의 값이 자식 노드의 값보다 항상 작거나 같은 힙

**힙의 특징**

* **완전 이진 트리:** 마지막 레벨을 제외하고 모든 레벨이 채워져 있고, 노드들은 왼쪽에서 오른쪽으로 채워지는 특징을 가집니다.
* **우선순위 큐:** 가장 큰 값(최대 힙) 또는 가장 작은 값(최소 힙)을 항상 루트 노드에 위치시켜 우선순위를 부여할 수 있습니다.
* **효율적인 삽입과 삭제:** 힙에 새로운 원소를 삽입하거나 기존 원소를 삭제하는 연산의 시간 복잡도가 O(log n)으로 매우 효율적입니다.

**힙의 시간 복잡도**

* **삽입(Insertion):** 새로운 원소를 힙에 삽입하고 힙의 성질을 유지하는 데 O(log n)의 시간이 소요됩니다.
* **삭제(Deletion):** 루트 노드(최댓값 또는 최솟값)를 삭제하고 힙의 성질을 유지하는 데 O(log n)의 시간이 소요됩니다.
* **검색(Search):** 특정 원소를 찾는 연산은 일반적으로 O(n)의 시간이 소요됩니다. 힙은 검색 연산에 최적화된 자료구조는 아니기 때문입니다.

**힙의 활용**

* **우선순위 큐:** 작업 스케줄링, 이벤트 처리 등 우선순위가 필요한 다양한 알고리즘에서 사용됩니다.
* **힙 정렬:** 힙을 이용하여 데이터를 정렬하는 알고리즘으로, 평균 및 최악의 경우 시간 복잡도가 O(n log n)입니다.
* **그래프 알고리즘:** 다익스트라 알고리즘 등 그래프 문제 해결에 사용됩니다.

**힙의 구현**

힙은 일반적으로 배열을 이용하여 구현합니다. 배열의 인덱스를 이용하여 노드 간의 관계를 표현하고, 힙의 성질을 유지하기 위한 힙화(heapify) 연산을 수행합니다.

**힙에 대한 추가 설명**

* **힙화(heapify):** 힙의 일부분이 힙의 성질을 만족하지 않을 때, 이를 다시 힙으로 만드는 과정입니다. 힙 삽입과 삭제 연산에서 힙화가 사용됩니다.
* **완전 이진 트리의 배열 표현:** 완전 이진 트리를 배열로 효율적으로 표현할 수 있습니다. 부모 노드의 인덱스를 i라고 할 때, 왼쪽 자식 노드의 인덱스는 2i+1, 오른쪽 자식 노드의 인덱스는 2i+2가 됩니다.

**결론적으로 힙은 우선순위 큐를 구현하는 데 매우 유용한 자료구조이며, 삽입과 삭제 연산이 효율적이라는 장점이 있습니다.**

### 우선순위 큐(Priority Queue)

`힙 자료구조`는 우선순위 큐를 구현하기 위해 사용하는 자료구조 중 하나다. 그리고 `우선순위 큐`는 우선순위가 가장 높은 데이터를 가장 먼저 pop시킨다는 것이 핵심 특징이다. 

대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리를 제공한다. 그래서 일반적인 코딩 테스트 환경에서는 우선순위 큐를 구현할 필요는 없다. 파이썬에서는 `heapq` 라이브러리에서 제공하는 우선순위 큐 라이브러리를 쓰는 것이 가장 좋다.

**우선순위 큐는 push할 때마다 항상 우선순위가 높은 데이터가 앞에 오도록 정렬한다. 그래서 우선순위 큐에서는 항상 우선순위가 높은 데이터부터 pop된다.** 예컨데, (가치, 물건) 형태의 데이터를 우선순위 큐에 저장하여 가치에 우선순위를 부여하여 pop을 시키면 가장 가치가 높은 물건 데이터가 먼저 튀어나온다. 대부분의 프로그래밍 언어에서는 첫 번째 원소를 우선순위 기준으로 삼으며, heapq 라이브러리도 그러하다.

**우선순위 큐 종류**

우선순위 큐에는 두 가지 종류가 있다.

- 최소 힙 : 우선순위 대상 데이터 값이 작은 데이터를 먼저 pop　(1 → 2 → 3 → …)
- 최대 힙 : 우선순위 대상 데이터 값이 큰 데이터를 먼저 pop　(100 → 99 → 98 → …)

heapq 라이브러리의 우선순위 큐는 `최소 힙`으로 구현되어 있다. 다익스트라 알고리즘의 경우 비용이 적은 순으로 탐색을 하므로, heapq 라이브러리에서 제공하는 우선순위 큐를 그대로 사용하여 다익스트라 알고리즘을 구현하면 된다. 

만약 문제를 풀기 위해서 최대 힙을 구현해야 한다면, 우선순위에 해당하는 값에 “음수 부호”를 붙여 저장한 뒤, 나중에 값을 꺼내어 출력할 때 다시 “음수 부호”를 곱하여 원래 값을 출력하도록 꼼수를 부릴 수 있다. 이 테크닉은 코딩 테스트에서 빈번히 쓸 수 있으므로 기억해두자.

참고로, 우선순위 큐를 구현할 때 힙 자료구조가 아닌 리스트를 사용해서도 구현할 수 있다. 그러나 리스트에서 값을 pop할 때마다 리스트 내 모든 원소를 순차탐색해서 가장 큰 우선순위 데이터를 찾아내야 하므로, 최악의 경우 시간복잡도 $O(N)$을 갖는다. 반면 힙으로 구현하면 시간복잡도 $O(logN)$을 갖기 때문에, 데이터 개수가 많아질수록 힙 자료구조로 구현된 우선순위 큐의 성능이 월등히 높아진다.

핵심 내용을 요약해보자. 

1. 이전 다익스트라 알고리즘은 일차원 리스트에 가장 가까운 노드를 저장했다. 그래서 만약 대량의 데이터가 입력되면, 제한 시간 내에 최단 거리 탐색을 수행해내지 못한다.
2. 반면 이번 개선된 다익스트라 알고리즘은 힙 자료구조로 구현된 우선순위 큐를 활용해 가장 가까운 노드를 저장한다. 여기서 성능 차이가 발생하는 것이다.

### 예제 코드(개선 후)

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
# 시작 노드 번호를 입력받기
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]
# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기
for _ in range(m):
    a, b, c = map(int, input().split())
    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b, c))

def dijkstra(start):
    q = []
    # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q: # 큐가 비어있지 않다면
        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        dist, now = heapq.heappop(q)
        # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:
            continue
        # 현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1]
            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

# 다익스트라 알고리즘을 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    # 도달할 수 있는 경우 거리를 출력
    else:
        print(distance[i])
```

이 코드는 단순히 최소 비용을 구하는 코드이다. 최단 경로 전체를 구하지는 않는다.

우선순위 큐를 사용하면서 visitTable을 정의할 필요가 없어지고, 매번 최소 node를 찾는 메소드 또한 구현할 필요가 없어졌다. 시간 복잡도도 낮아질 뿐더러 코드 복잡도 또한 낮아지는 일석이조의 효과.

우선순위 큐의 성질 덕분에, 위 코드 상에서 한 번 처리된 노드는 다시 처리할 일이 생기지 않는다. 매번 push할 때마다 우선순위가 높은 애들이 항상 앞에 오도록 정렬되고, 그래서 비용이 낮은 애들이 항상 앞에서 pop되어 최단거리 테이블을 마감시키기 때문이다. 그러므로 방문 테이블을 구현할 필요가 없다. 결과적으로 반복문에서 노드를 탐색하는 횟수는 노드의 개수 V 만큼이며(힙에 넣을 때마다 계속 갱신됨), 각 탐색마다 해당 노드 자신과 연결된 간선들의 비용을 모두 확인하기 때문에 간선의 개수 E만큼 추가적인 연산이 들어간다. 우선순위 큐를 적용한 다익스트라 알고리즘의 시간 복잡도는 $O(ElogV)$가 된다. 물론 직접 우선순위 큐를 구현하지는 않았으니 당장은 이해하기 어렵겠지만, 일단 위 코드를 숙지하는 것은 필수다. 깊은 이해가 필요하다면 구글링을 해보라.



```java
import java.util.*;

class Node implements Comparable<Node> {

    private int index;
    private int distance;

    public Node(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    public int getIndex() {
        return this.index;
    }

    public int getDistance() {
        return this.distance;
    }

    // 거리(비용)가 짧은 것이 높은 우선순위를 가지도록 설정
    @Override
    public int compareTo(Node other) {
        if (this.distance < other.distance) {
            return -1;
        }
        return 1;
    }
}

public class Main {

    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정
    // 노드의 개수(N), 간선의 개수(M), 시작 노드 번호(Start)
    // 노드의 개수는 최대 100,000개라고 가정
    public static int n, m, start;
    // 각 노드에 연결되어 있는 노드에 대한 정보를 담는 배열
    public static ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();
    // 최단 거리 테이블 만들기
    public static int[] d = new int[100001];

    public static void dijkstra(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        // 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
        pq.offer(new Node(start, 0));
        d[start] = 0;
        while(!pq.isEmpty()) { // 큐가 비어있지 않다면
            // 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
            Node selectNode = pq.poll();
            // 현재 노드가 이미 처리된 적이 있는 노드라면 무시
            if (d[selectNode.getIndex()] < selectNode.getDistance()) 
                continue;
            // 현재 노드와 연결된 다른 인접한 노드들을 확인
            for (Node node : graph.get(selectNode.getIndex())) {
                int cost = d[selectNode.getIndex()] + node.getDistance();
                // 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
                if (cost < d[node.getIndex()]) {
                    d[node.getIndex()] = cost;
                    pq.offer(new Node(node.getIndex(), cost));
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        m = sc.nextInt();
        start = sc.nextInt();

        // 그래프 초기화
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<Node>());
        }
        
        // 모든 간선 정보를 입력받기
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            // a번 노드에서 b번 노드로 가는 비용이 c라는 의미
            graph.get(a).add(new Node(b, c));
        }

        // 최단 거리 테이블을 모두 무한으로 초기화
        Arrays.fill(d, INF);
        
        // 다익스트라 알고리즘을 수행
        dijkstra(start);

        // 모든 노드로 가기 위한 최단 거리를 출력
        for (int i = 1; i <= n; i++) {
            // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
            if (d[i] == INF) {
                System.out.println("INFINITY");
            }
            // 도달할 수 있는 경우 거리를 출력
            else {
                System.out.println(d[i]);
            }
        }
    }
}
```
Java로 구현하니까 동일한 class type에 대한 서로 다른 인스턴스의 데이터 수치 비교 시 코드 로직이 훨씬 잘 보인다. 다양한 언어를 써서 동일한 로직을 구현하면, 확실히 다른 관점에서 보게 되니 시야가 넓어지는 것 같다.

### 예제 입력

```
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
```

### 예제 출력

```
0
2
3
1
2
4
```

다익스트라 알고리즘은 우선순위 큐를 이용하기 때문에, 우선순위 큐를 요구하는 다른 고급 문제들을 푸는 데에도 큰 도움을 준다. 그러니 다익스트라 알고리즘을 완벽히 이해할 수 있을 때까지 학습하는 것이 좋다.



# 플로이드 워셜 알고리즘

다익스트라 알고리즘의 경우 “한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 경우”에 사용했다. 반면 `플로이드 워셜 알고리즘`은 “모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 경우”에 사용하는 알고리즘이다. 다익스트라 알고리즘과는 다르게 방문한 노드를 재방문하여 전체 탐색을 하는 것이 가장 큰 차이점이다. 노드의 개수가 N개일 때, 알고리즘을 N번 반복하여 $O(N^{2})$의 연산을 하여 현재 노드를 거쳐가는 모든 경로를 전부 고려한다. 그래서 플로이드 워셜 알고리즘의 시간복잡도는 $O(N^{3})$이 된다. 성능은 최악이지만, 다이나믹 프로그래밍을 활용하여 구현하기 때문에 코드 구현은 매우 쉬워진다는 장점이 있다.

다익스트라 알고리즘은 1차원 리스트를 사용하여 선택한 노드 하나에 대한 최단 거리 테이블을 구현했다. 하지만 플로이드 위셜 알고리즘은 2차원 리스트로 전체 노드에 대한 최단 거리 테이블을 구현한다.(주로 행쪽을 src, 열쪽을 dst로 두어 저장) 다익스트라 알고리즘은 매 반복마다 가장 비용이 적은 노드를 선택해서 탐색을 반복하는 “그리디 알고리즘”으로 진행되었다. 반면 플로이드 위셜 알고리즘은 노드 개수 N번 만큼의 단계를 반복하여 점화식에 맞게 2차원 리스트인 최단 거리 테이블을 갱신하기 때문에 “다이나믹 프로그래밍”으로 볼 수 있다.

플로이드 위셜 알고리즘의 점화식은 아래와 같다.

$D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$

위 점화식은 두 비용 중, 더 작은 값을 a(src)에서 b(dst)로 가는 최소 비용으로 결정한다.

- a에서 b로 가는 최소 비용
- a에서 k를 거쳐 b로 가는 최소 비용

여기서 저 k값에 각각의 노드들이 한 번씩 들어가면서 a,b쌍을 모두 순차탐색하여 점화식을 실행시킨다. a,b쌍에 대한 순차탐색은 $O(N^2)$이고, k는 총 $O(N)$번 돌기 때문에 최종적으로 $O(N^3)$가 되는 것이다.

이는 3중 반복문을 활용해 쉽게 구현할 수 있다.

### 예제 코드

```python
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수 및 간선의 개수를 입력받기
n = int(input())
m = int(input())
# 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n + 1) for _ in range(n + 1)]

# 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for i in range(1, n + 1):
    graph[i][i] = 0

# 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
for _ in range(m):
    # A에서 B로 가는 비용은 C라고 설정
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# 수행된 결과를 출력
for a in range(1, n + 1):
    for b in range(1, n + 1):
        # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
        if graph[a][b] == 1e9:
            print("INFINITY", end=" ")
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(graph[a][b], end=" ")
    print()
```

- 플로이드 위셜 알고리즘을 구현할 때는 그래프와 최소 거리 테이블을 동일시한다.
- 자기 자신에게 가는 비용은 항상 0이다. 그래서 최소 거리 테이블 상에서 왼쪽 위에서 오른쪽 아래로 내려가는 대각 방향의 모든 값은 전부 0이 된다.
- 점화식을 사용하여 그래프 내 전체 경우의 수에 대한 최단 거리를 구한다.

```java
import java.util.*;

public class Main {

    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정
    // 노드의 개수(N), 간선의 개수(M)
    // 노드의 개수는 최대 500개라고 가정
    public static int n, m;
    // 2차원 배열(그래프 표현)를 만들기
    public static int[][] graph = new int[501][501];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        m = sc.nextInt();

        // 최단 거리 테이블을 모두 무한으로 초기화
        for (int i = 0; i < 501; i++) {
            Arrays.fill(graph[i], INF);
        }

        // 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
        for (int a = 1; a <= n; a++) {
            for (int b = 1; b <= n; b++) {
                if (a == b) graph[a][b] = 0;
            }
        }

        // 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
        for (int i = 0; i < m; i++) {
            // A에서 B로 가는 비용은 C라고 설정
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            graph[a][b] = c;
        }

        // 점화식에 따라 플로이드 워셜 알고리즘을 수행
        for (int k = 1; k <= n; k++) {
            for (int a = 1; a <= n; a++) {
                for (int b = 1; b <= n; b++) {
                    graph[a][b] = Math.min(graph[a][b], graph[a][k] + graph[k][b]);
                }
            }
        }

        // 수행된 결과를 출력
        for (int a = 1; a <= n; a++) {
            for (int b = 1; b <= n; b++) {
                // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
                if (graph[a][b] == INF) {
                    System.out.print("INFINITY ");
                }
                // 도달할 수 있는 경우 거리를 출력
                else {
                    System.out.print(graph[a][b] + " ");
                }
            }
            System.out.println();
        }
    }
}
```

### 예제 입력

```
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
```

### 예제 출력

```
0 4 8 6
3 0 7 9
5 9 0 4
7 11 2 0
```

# 다익스트라 알고리즘과 플로이드 워셜 알고리즘의 활용 예시

### 다익스트라 알고리즘

다익스트라 알고리즘은 **단일 출발점에서 모든 정점까지의 최단 경로**를 찾는 데 특화된 알고리즘입니다. 따라서 **출발점이 명확하고, 간선의 가중치가 음수가 아닌 경우**에 효과적으로 사용됩니다.

* **네트워크 라우팅:**
    * 특정 네트워크 노드에서 다른 모든 노드까지 데이터 패킷을 전송할 때, 가장 빠른 경로를 찾아 네트워크 트래픽을 최적화합니다.
    * 예시: 인터넷에서 웹 페이지를 요청할 때, 가장 빠른 경로를 통해 서버에 접속합니다.
* **지도 앱:**
    * 특정 위치에서 다른 위치까지 이동할 때, 가장 빠른 길을 찾아줍니다.
    * 예시: 네이버 지도, 구글 지도 등에서 목적지를 설정하고 길찾기를 할 때 사용됩니다.
* **최소 스패닝 트리:**
    * 모든 노드를 연결하는 최소 비용의 트리를 찾는 문제에서, 다익스트라 알고리즘을 응용하여 해결할 수 있습니다.
* **최단 경로 문제:**
    * 공장에서 제품을 생산하여 고객에게 배송할 때, 최소 비용으로 배송할 수 있는 경로를 찾는 문제 등 다양한 최단 경로 문제에 활용됩니다.

### 플로이드 워셜 알고리즘

플로이드 워셜 알고리즘은 **모든 정점 쌍 사이의 최단 경로**를 찾는 데 사용되는 알고리즘입니다. 다익스트라 알고리즘과 달리, **간선의 가중치가 음수일 경우에도** 사용할 수 있다는 장점이 있습니다.

* **최소 비용 경로 찾기:**
    * 여러 도시 간의 최소 비용으로 이동하는 경로를 찾는 문제
    * 예시: 항공권 예약 시, 여러 도시를 경유하여 최소 비용으로 여행하는 경로를 찾는 문제
* **그래프 분석:**
    * 소셜 네트워크 분석에서 두 사용자 간의 연결 강도를 파악하거나, 생물학적 네트워크 분석에서 단백질 상호작용 네트워크에서 두 단백질 사이의 최단 경로를 찾는 데 사용됩니다.
* **추천 시스템:**
    * 사용자의 선호도를 기반으로 아이템 간의 유사도를 계산하여 추천 시스템에 활용됩니다.
* **게임 개발:**
    * 게임 캐릭터가 목표 지점까지 이동할 때, 가장 빠른 경로를 찾는 데 사용됩니다.

**두 알고리즘의 차이점 요약**

| 특징 | 다익스트라 알고리즘 | 플로이드 워셜 알고리즘 |
|---|---|---|
| 목적 | 단일 출발점에서 모든 정점까지의 최단 경로 | 모든 정점 쌍 사이의 최단 경로 |
| 가중치 제한 | 음수 가중치 불가 | 음수 가중치 가능 |
| 시간 복잡도 | O(V^2 + ElogV) | O(V^3) |
| 공간 복잡도 | O(V^2) | O(V^2) |

**어떤 알고리즘을 사용해야 할지 고민될 때는 다음과 같은 요소를 고려해야 합니다.**

* **문제의 특성:** 단일 출발점 문제인지, 모든 정점 쌍 문제인지
* **간선의 가중치:** 음수 가중치가 있는지
* **데이터 크기:** 정점과 간선의 수
* **알고리즘의 시간 복잡도:** 빠른 계산이 필요한 경우

**결론적으로, 다익스트라 알고리즘과 플로이드 워셜 알고리즘은 다양한 분야에서 최단 경로 문제를 해결하는 데 널리 사용되는 강력한 도구입니다.**

**더 궁금한 점이 있으시면 언제든지 질문해주세요.** 
