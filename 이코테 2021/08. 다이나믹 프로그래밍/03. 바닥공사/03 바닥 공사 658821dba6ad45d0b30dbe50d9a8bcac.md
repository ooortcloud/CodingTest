# 03. 바닥 공사

## 문제 정보

가로 길이가 n, 세로 길이가 2인 직사각형 형태의 얇은 바닥이 있다. 태일이는 이 얇은 바닥을 1*2의 덮개, 2*1의 덮개, 2*2의 덮개를 이용해 채우고자 한다.

이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 2*3 크기의 바닥을 채우는 경우의 수는 5가지이다.

### 입력

- 첫째 줄에 n이 주어진다. (1 이상 1000 이하)

### 출력

- 첫째 줄에 2*n 크기의 바닥을 채우는 방법의 수를 796796으로 나눈 나머지를 출력한다.

### 예제 입력 1

```python
3
```

### 예제 출력 1

```python
5
```

## 문제의 의도

- 다이나믹 프로그래밍을 활용해 구현할 수 있는가?

### 아이디어

- n이 홀수, 짝수일 때마다 규칙성을 갖는 것 같다.

### 풀이

- 내 풀이(오답)

```python
width = int(input())  # n
length = 2

d = [0] * 1001  # 인덱스 : width , 값 : 경우의 수

d[1] = 1
d[2] = 3
for i in range(3, width+1):
    if (i % 2 != 0):
        d[i] = d[i-1] + 2
    else:
        d[i] = d[i-2] * d[2]

print(d[width])
```

이 문제의 핵심은 아래 세 가지이다.

![Untitled](03%20%E1%84%87%E1%85%A1%E1%84%83%E1%85%A1%E1%86%A8%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%89%E1%85%A1%20658821dba6ad45d0b30dbe50d9a8bcac/Untitled.png)

1. 우선 n=1, 2일 때 초기값을 정의해야 한다.(다이나믹 프로그래밍 특, 순열의 특징이기도 하다.)
    1. n = 1인 경우 가능한 경우의 수는 1개.
    2. n = 2인 경우 가능한 경우의 수는 3개.
2. 이제 n ≥ 3 이상인 경우의 규칙성을 파악한다.
    1. n이 홀수인 경우, 이전 경우의 수에 + 1. 왜냐하면 이전 덮개에 2*1짜리 덮개를 끝에 추가하는 것이 최선이기 때문이다.
    2. n이 짝수인 경우, n-2인 경우의 수에 n=2일 때의 경우의 수를 곱한다.

… 하지만 이는 정답에 근접한 풀이일 뿐, 정답은 아니다.

- 답안 풀이

```python
width = int(input())  # n

d = [0] * 1001  # 인덱스 : width , 값 : 경우의 수

d[1] = 1
d[2] = 3
for i in range(3, width+1):
    d[i] = (d[i-1] + d[i-2]*2) % 796796

print(d[width])
```

아래처럼 생각했어야 했다.

![Untitled](03%20%E1%84%87%E1%85%A1%E1%84%83%E1%85%A1%E1%86%A8%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%89%E1%85%A1%20658821dba6ad45d0b30dbe50d9a8bcac/Untitled%201.png)

이렇게 했을 때 점화식은 아래와 같다.

$a_{i} = a_{i-1} + a_{i-2}*2$

이를 코드화해서 그냥 바텀업 반복문 안에 넣은 뒤 DP 테이블을 계속 채워나가면 끝이다. 

여기서 의문을 품을 수 있다. 2*1 덮개를 연속으로 두면 2*2 덮개가 되므로 3배를 곱해야 하는 것 아니냐고. 하지만 이 케이스는 사실상 i-1번째 인 경우에 덮개를 덮는 경우가 두 번 연속으로 이어지는 것과 같으므로 이미 i-1번째에서 경우의 수가 처리된 것과 마찬가지이다. 그러므로 이게 맞다.