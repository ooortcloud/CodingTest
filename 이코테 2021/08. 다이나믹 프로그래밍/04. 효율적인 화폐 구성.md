# 04. 효율적인 화폐 구성

## 문제 정보

n가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 m원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

### 입력

- 첫째 줄에 n, m이 주어진다. (n은 1 이상 100 이하, m은 1 이상 10000 이하)
- 이후 n개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 10000보다 작거나 같은 자연수이다.

### 출력

- 첫째 줄에 m원을 만들기 위한 최소한의 화폐 개수를 출력한다.
- 불가능할 때는 -1을 출력한다.

### 예제 입력 1

```python
2 15
2
3
```

### 예제 출력 1

```python
5
```

### 예제 입력 2

```python
3 4
3
5
7
```

### 예제 출력 2

```python
-1
```

## 문제의 의도

- 다이나믹 프로그래밍으로 위 문제를 해결할 수 있는가?

### 아이디어

- 바텀업 다이나믹 프로그래밍을 구현해보자.

### 풀이

- 내 풀이(오답)

```python
n, m = map(int, input().split())

coins = list()
for _ in range(n):
    coins.append(int(input()))

d = [0] * (m+1)
temp = list()
for i in range(1, m+1):
    for coin in coins:
        if i % coin == 0:
            if d[i] == 0:
                d[i] = i // coin
            else:
                d[i] = min(i // coin, d[i])
        else:
            if i < min(coins):
                d[i] = -1
            else:
                val = i - coin
                if d[val] > 0:
                    temp.append(d[val])
    
    print(temp)
    if temp and d[i]==0:
            d[i]= min(temp) + 1
    temp.clear()
        
print("d = ", d)
print(d[m])
```

완전 스파게티 코드에, 제대로 동작하지도 않는다… 너무 어렵다.

- 답안 풀이

```python
n, m = map(int, input().split())

coins = list()
for _ in range(n):
    coins.append(int(input()))

d = [10001] * (m+1)

d[0] = 0
for i in range(n):
    for j in range(coins[i], m+1):
        if d[j - coins[i]] != -1:
            d[j] = min(d[j], d[j - coins[i]] + 1)
        print(d)

if d[m] == 10001:
    print(-1)
else:
    print(d[m])
```

이번 문제도 단순히 점화식을 구현할 수는 없는 멀티버스(?) 형태의 문제였다. 그래서 우리가 일반적으로 생각하는 그 수열 형태의 점화식을 구현하려 했으니 불가능했던 것.

---

이 문제의 점화식은 아래와 같다.

화폐 단위 별로 가장 작은 금액부터 가장 큰 금액까지 차례대로 최소 화폐 개수를 찾는다. 이때 어떤 금액 i를 만들 수 있는 최소 화폐 개수를 $a_{i}$, 화폐의 단위를 k라고 했을 때, 금액 i-k를 만들 수 있는 최소 화폐 개수 $a_{i-k}$는…

1. $a_{i-k}$를 만들 수 있는 경우 : $a_{i} = min(a_{i}, a_{i-k} + 1)$
    
    여기서 정의되지도 않은 최소 화폐 개수에 대해서 어떻게 최솟값을 비교하냐는 의문을 품을 수 있다. 여기서 말하는 최소 화폐 개수는 멀티버스에서 다른 화폐를 사용했을 때 최소 화폐 개수와 비교하는 것이다. 그래서 2의 화폐를 쓴 시간선과 3의 화폐를 쓴 시간선을 서로 비교해서 둘 중 더 적은 화폐를 사용한 쪽의 손을 들어주는 것이다. 이것을 하기 위해 초기값을 입력의 최대값인 10000보다 큰 10001로 설정해둔 것이고.
    
2. $a_{i-k}$를 만들 수 없는 경우 :  $a_{i} = 10001$

이론 상 이해를 했다고 해도 구현하는 건 또 다른 문제다. 단순히 일차 반복만 하면 되는 단순 수열 형태의 점화식이 있는 반면, 멀티버스 형태의 경우 문제에 따라 반복문을 구현하는 방식이 다 달라지기 때문이다. 예컨데, 이 문제에서는 각 코인 별로 처음부터 끝까지 코인 사용 개수를 순차적으로 기록해두고 다시 다른 코인에 대해서 반복하는 반면, 앞선 개미전사 문제에서는 일차 반복하는 상태에서 두 가지의 멀티버스를 계속 반복적으로 탐색하며 값을 비교했다. 그래서 DP를 잘 하려면 요 멀티버스 유형을 마스터해야 할 것으로 보인다.