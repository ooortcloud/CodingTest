# 00. 설명

# 다이나믹 프로그래밍

## 중복되는 연산을 줄이자

피보나치 수열은 아래와 같은 점화식을 갖는다.

$a_{n+2} = a_{n+1} + a_{n} (단, a_{1} = a_{2} = 1)$

프로그래밍에서는 이러한 수열을 배열 또는 리스트로 표현할 수 있다. 예를 들어 아래 코드처럼 말이다.

```python
def fibo(x):
	if x==1 or x==2:
		return 1
	return fibo(x-1) + f(x-2)

print(fibo(7))
```

하지만 이런 식으로 작성하면 시간복잡도가 약 $O(2^{N})$이 되는데, 이는 N=30인 경우 약 10억 번의 연산을 수행해야 하는 정도의 최악의 시간복잡도이다. 

하지만 잘 살펴보면 똑같은 함수가 여러 번 호출되는 것을 볼 수 있다. N=4, 5, 6, 7.. 인 피보나치 함수는 항상 f(3)의 값을 연산해야 한다. 이러한 문제는 `다이나믹 프로그래밍` 을 사용하여 해결할 수 있다.

다이나믹 프로그래밍은 큰 문제를 작은 문제로 나누어 풀어가는 알고리즘이다. 이를 사용하기 위한 조건은 아래와 같다.

1. **큰 문제를 작은 문제로 나눌 수 있다.**
2. **작은 문제에서 구한 정답이 큰 문제에서 구한 정답과 동일하다.**

피보나치 수열은 이 조건을 만족하는 대표적인 예제이다. 그러므로 피보나치 수열 문제를 해결할 때 다이나믹 프로그래밍을 활용할 수 있는데, 다이나믹 프로그래밍을 구현하는 방법 중 하나인 `메모이제이션(캐싱)`이라는 방식으로 해결해볼 수 있다.

메모이제이션을 구현하는 방식은 매우 간단하다. 한 번 구한 정보를 리스트에 저장하여, 다음에 동일한 정보를 연산해야 할 때 리스트에서 그 결과값을 꺼내오는 방식이다.

```python
memoizationList = [0] * 100

def fibo(x):
    if x==1 or x==2:
        return 1
    
    if memoizationList[x] != 0:
        return memoizationList[x]
    
    memoizationList[x] = fibo(x-1) + fibo(x-2)
    return memoizationList[x]

print(fibo(99))  # 218922995834555169026
```

그래서 이 말도 안되는 값의 연산을 1초도 안돼서 해낼 수 있게 된다.

큰 문제를 작은 문제로 해결하는 방식은 앞서 퀵 정렬의 분할 정복 알고리즘에서 이미 마주한 적이 있다. 하지만 분할 정복과 다이나믹 프로그래밍에는 큰 차이점이 하나 있다. 바로 분할 정복은 문제들이 서로에게 영향을 끼치지 않는다는 점이다.

퀵 정렬을 생각해보자. 일단 피벗 하나를 끝내서 자리를 잡게 하면, 이 피벗은 다음 퀵 정렬 연산에 어떤 식으로든 영향을 미치지 않는다. 하지만 피보나치 수열의 경우, 이전 연산값이 항상 다음 연산에 영향을 미치게 된다. 

---

다이나믹 프로그래밍을 구현하는 경우, 보통 예제 코드로 재귀 함수를 구현하여 보여주지만 성능 적으로는 반복문으로 구현하는 것이 더 좋다. 재귀 함수를 사용하는 경우 의도치 않게 메모리 상에서 오버헤드가 발생할 수 있기 때문이다.

다이나믹 프로그래밍을 적용하게 되면, 피보나치 수열의 경우 시간복잡도가 $O(2^{N})$에서 $O(N)$으로 성능이 크게 좋아지게 된다. 왜냐하면 앞에서 한 번 구한 결과값을 미리 풀어놓은 상태에서는 더 이상 이전의 값들을 연산할 필요가 없이 값을 불러오기만 하면 되기 때문이다. 즉, 연산을 N 당 한 번씩만 하면 된다.

```python
memoizationList = [0] * 100

def fibo(x):
    print('f(' + str(x) + ')', end=' ')

    if x==1 or x==2:
        return 1
    
    if memoizationList[x] != 0:
        return memoizationList[x]
    
    memoizationList[x] = fibo(x-1) + fibo(x-2)
    return memoizationList[x]

fibo(9)  # f(9) f(8) f(7) f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4) f(5) f(6) f(7)
```

이렇게 재귀 함수를 이용해서 다이나믹 프로그래밍을 구현하는 방법을 `탑다운(하향식)` 방식이라고 한다.

반면 반복문을 사용해서 다이나믹 프로그래밍을 구현하는 방법은 `바텀업(상향식)` 방식이라고 한다.

```python
memoizationList = [0] * 100

memoizationList[1], memoizationList[2] = 1, 1  # 인덱스 가독성을 위해 0번째는 버림
n = 99

for i in range(3, n+1):
    memoizationList[i] = memoizationList[i-1] + memoizationList[i-2]

print(memoizationList[n])  # 218922995834555169026
```

일반적으로 다이나믹 프로그래밍을 구현할 때는 성능 이슈 때문에 “바텀업” 방식으로 구현하게 된다.  바텀업 방식에서 사용되는 결과 저장용 리스트를 “DP 테이블”이라고 한다.

참고로 메모이제이션의 경우에는 탑다운 방식에서만 볼 수 있는데, 엄밀히 말하면 메모이제이션은 다이나믹 프로그래밍은 아니다. 

---

메모이제이션은 상황에 따라 딕셔너리 자료구조로 구현할 수도 있다. 예컨데 연속적이지 않은 문제에 대한 해답을 제시해야 하는 경우에 딕셔너리 구조를 사용하면 고성능으로 구현할 수 있다.

하지만 코딩 테스트의 다이나믹 프로그래밍은 대체로 간단한 형태로 출제되기 때문에 이 장에서 다루는 문제 수준만 풀 수 있어도 충분하다. 코딩 테스트에서 다이나믹 프로그래밍 문제 푸는 팁은 아래와 같다.

- 주어진 문제가 완전 탐색 알고리즘으로 접근했을 때 시간이 엄청 오래 걸리면 해당 문제는 다이나믹 프로그래밍 솔루션을 요구할 확률이 높다. 해결해야 하는 작은 부분들이 쓸데없이 계속 중복으로 연산되는지 확인해보자.
- 다이나믹 프로그래밍을 구현할 때는 바텀업 방식으로 구현하자. 탑다운 방식은 스택 오버플로우가 발생할 수 있기 때문이다.
- 일단 재귀함수를 구현했는데 해당 구현 방식이 비효율적인 경우, 메모이제이션을 활용하여 보완하는 방법도 좋은 방법이다.