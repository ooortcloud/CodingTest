# 금광

## 문제 정보

n*m 크기의 금광이 있습니다. 금광은 1*1 크기의 칸으로 나뉘어 있으며, 각 칸은 특정한 크기의 금이 들어있습니다. 채굴자는 첫 번째 열부터 출발하여 금을 캐기 시작합니다. 맨 처음에는 첫 번째 열의 어느 행에서든 출발할 수 있습니다. 이후에 m번에 걸쳐서 매번 오른쪽 위, 오른쪽, 오른쪽 아래 3가지 중 하나의 위치로 이동해야 합니다. 결과적으로 채굴자가 얻을 수 있는 금의 최대 크기를 출력하는 프로그램을 작성하세요.

만약 다음과 같이 3*4 크기의 금광이 존재한다고 가정합시다.

| 1 | 3 | 3 | 2 |
| --- | --- | --- | --- |
| 2 | 1 | 4 | 1 |
| 0 | 6 | 4 | 7 |

가장 왼쪽 위의 위치를 (1, 1), 가장 오른쪽 아래의 위치를 (n, m)이라고 할 때, 위 예시에서는 (2, 1) → (3,2) → (3,3) → (3,4)의 위치로 이동하면 총 19만큼의 금을 채굴할 수 있으며, 이 값이 최댓값입니다.

### 문제 요약

채굴자가 얻을 수 있는 금의 최대 크기를 출력하는 프로그램을 작성하세요.

### 입력

- 첫째 줄에 테스트 케이스 t가 입력됩니다. (1 이상 1000 이하)
- 매 테스트 케이스 첫째 줄에 n과 m이 공백으로 구분되어 입력됩니다. (1 이상 20 이하)
- 둘째 줄에 n*m개의 위치에 매장된 금의 개수가 공백으로 구분되어 입력됩니다. (매장된 금의 개수는 1 이상 100 이하)

### 출력

- 테스트 케이스마다 채굴자가 얻을 수 있는 금의 최대 크기를 출력합니다. 각 테스트 케이스는 줄 바꿈을 이용해 구분합니다.

### 예제 입력 1

```python
2
3 4
1 3 3 2 2 1 4 1 0 6 4 7
4 4
1 3 1 5 2 2 4 1 5 0 2 3 0 6 1 2
```

### 예제 출력 1

```python
19
16
```

## 문제의 의도

- 다이나믹 프로그래밍을 이용하여 문제를 해결하시오.

### 아이디어

- 매 column마다 위를 선택했는지 아래를 선택했는지에 따라 어느 쪽이 더 이득인지 비교하면서 최대 채굴량을 출력하면 된다.
- DP 테이블을 각 row마다 하나씩 만들어서 대응해야 한다. 경우의 수가 너무 많아서…

### 풀이

- 내 풀이

```python
t = int(input())

for _ in range(t):
    n , m =  map(int, input().split())  # n : row, m : column

    inputMine = list(map(int, input().split()))
    rowMine = list()    # rowmine[row][column]
    rowMine.append(0)  # column 인덱스 1부터 시작하도록 맞춤

    for i in range(n):
        rowList = list()
        rowList.append(0)  # row 인덱스 1부터 시작하도록 맞춤
        rowMine.append(rowList)
        for j in range(i*m, (i+1)*m):
            rowList.append(inputMine[j])

    print(rowMine)

    d = [[0] for _ in range(m+1)]   # d[column][row]
    for j in range(1, n+1):
        d[1].append(rowMine[j][1])
    for i in range(2, m+1):
        for j in range(1, n+1):
            if j == 1:
                d[i].append(max(d[i-1][j], d[i-1][j+1]) + rowMine[j][i]) 
            elif j == n:
                d[i].append(max(d[i-1][j-1], d[i-1][j]) + rowMine[j][i]) 
            else:
                d[i].append(max(d[i-1][j-1], d[i-1][j], d[i-1][j+1]) + rowMine[j][i]) 
    print(d)
    print(max(d[m]))
```

이 문제를 구현하면서 가장 애먹었던 부분은 구현 단계에서 rowMine과 DP 테이블의 row와 column의 차원 위치가 정반대여서 매우 헷갈렸다는 것. 최대한 row와 column을 서로 일치시키는 것이 좋았을텐데, 사실 구현하다보면 자연스럽게 둘의 위치가 바뀌게 돼서… 만약 서로 일치시켜주려면 둘 중 하나는 구현을 매우 복잡하게 해야만 한다.

DP 테이블을 설계하는 것도 쉽지 않았다. 이전 문제들과는 다르게 DP 테이블에서 각 인덱스마다 특정 column의 각 row마다 최대가 되는 값을 전부 저장했어야 하기 때문이다. 문제를 분석하고 나니 DP 테이블의 각 인덱스를 리스트로 넣어주면 된다는 것을 파악할 수 있었다. 그리고 리스트를 넣을 때 기존처럼 리스트에 상수 곱 형태로 구현하게 되면 리스트가 얕은 복사가 돼서 모든 인덱스에 동일한 값들이 append되는 것을 확인할 수 있다. 이 문제는 리스트 컴프리헨션을 사용해서 쉽게 해결할 수 있었다.