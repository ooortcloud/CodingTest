# 01. 1로 만들기

## 문제 정보

정수 x가 주어질 때 정수 x에 사용할 수 있는 연산은 다음과 같이 4가지이다.

1. x가 5로 나눠 떨어지면 5로 나눈다.
2. x가 3으로 나눠 떨어지면 3으로 나눈다.
3. x가 2로 나눠 떨어지면 2로 나눈다.
4. x에서 1을 뺀다.

정수 x가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

예를 들어 정수가 26이면 아래와 같이 계산해서 3번의 연산이 최솟값이다.

1. 26 - 1 = 25
2. 25/5 = 5
3. 5/5 = 1

### 문제 요약

연산을 사용하는 횟수의 최솟값을 출력하시오.

### 입력

- 첫째 줄에 정수 x가 주어진다. (1이상 30000 이하)

### 출력

- 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

## 문제의 의도

- 다이나믹 프로그래밍으로 문제를 해결할 수 있는가?

### 아이디어

- 이게 왜 다이나믹 프로그래밍이지? 브루트 포스 아닌가?

### 풀이

- 내 풀이(오답)

```python
x = int(input())

cases = list(tuple())
for five in range(x // 5 + 1):
    for three in range(x // 3 + 1):
        for two in range(x // 2 + 1):
            for one in range(x):
                cases.append((five*5 + three*3 + two*2 +one, five + three + two + one))

min = 30001
for sum, num in cases:
    if sum == x:
        if min > num:
            min = num

print(min)
```

어… 아닌가?

- 교재 답안

```python
x = int(input())

# DP 테이블 초기화
d = [0] * 30001

# 바텀업 다이나믹 프로그래밍 구현
for i in range(2, x+1):
    # 일단 앞에서 1을 뺐다고 가정
    d[i] = d[i-1] + 1  

    # 그런데 1을 뺀 것보다 나머지가 더 효율적이면 해당 값으로 변경.
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])
```

DP 테이블의 경우 일종의 계수 정렬과 비슷한 방식으로 인덱스를 활용했다.

그리고 바텀업 방식으로 다이나믹 프로그래밍을 구현했는데, 앞선 가장 최적의 연산 결과에 대해서 다음 숫자의 최적의 연산에 영향을 주는 것을 핵심 포인트로 생각하여 구현해야 한다. 예컨데 14에 대해서 위 조건에 대해서 가장 적은 횟수로 연산을 하기 위해, 14 앞의 숫자들의 가장 최적의 숫자를 이미 다 구한 상태에서 각 경우(1을 뺀다 vs 2를 나눈다 vs 3을 나눈다 vs 5를 나눈다)에 따라 비교하여 가장 효율적인 방안을 모색하는 방법으로 구현한 것이다. 이렇게 하면 모든 숫자에 대해서 가장 최적의 연산 횟수를 빠르고 정확하게 구할 수 있다.

여담으로, **브루트 포스와 바텀업 다이나믹 프로그래밍의 차이점은 바로 이전의 상태가 이후의 상태에 영향을 주는가이다**. 바텀업의 경우, 앞의 설명에서 보았듯 이전의 상태에 절대적으로 의존하게 된다. 반면 브루트 포스는 단순히 모든 경우에 대해서 열거하여 답을 찾는 방식이기 때문에 이전 상태와 완전히 격리되어 있다. 둘이 구현하는데 비슷해 보이는 이유는 모든 경우의 수에 대해 미리 계산해두고 정답을 찾는 방식이 동일해 보이기 때문이다. 하지만! 세부 계산 과정은 완전히 다르다는 것에 주의하자!