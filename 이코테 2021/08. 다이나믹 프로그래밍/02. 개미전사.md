# 02. 개미 전사

## 문제 정보

개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있다. 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이떄 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다. 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 

예를 들어 식량창고 4개가 다음과 같이 존재한다고 가정하자.

```python
{1, 3, 1, 5}
```

이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다. 개미 전사는 식량창고가 이렇게 일직선상일 때 최대한 많은 식량을 얻기를 원한다.

개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 식량창고의 개수 n이 주어진다. (3 이상 100 이하)
- 둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 k가 주어진다. (0 이상 1000 이하)

### 출력

- 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하시오.

### 입력 예제

```python
4
1 3 1 5
```

### 출력 예제

```python
8
```

## 문제의 의도

- 다이나믹 프로그래밍으로 문제를 해결하시오.

### 아이디어

도저히 감이 안 잡힌다.

- n이 큰 수일 경우 어떻게 여러 가지의 경우의 수에 대해 완전 탐색하는 것을 구현할 수 있는지? (그러니까 1칸 떨어질지 2칸 떨어질지 이걸 각 경우마다 어떻게 구현할 것인가?)
- 모든 경우마다 떨어지는 칸 수가 다 다른데, 도대체 어디서 이전 상태로부터 값을 불러들여야 하는지? 그냥 재귀 함수로써 상태 파라미터 전달하는 것이랑 뭐가 다른지?

### 풀이

- 답안 풀이

```python
n = int(input())
foodStorage = list(map(int, input().split()))

# DP 테이블에 이전 상태값 중 최댓값이 되는 경우에 대해 누적시켜나감.
d = [0] * n

d[0] = foodStorage[0]
d[1] = max(d[0], foodStorage[1])
for i in range(2, n):
    d[i] = max(d[i-1] , d[i-2] + foodStorage[i])

print(d[n-1])
```

이전 문제에서는 최적의 값이 되는 경우에 따라 DP 테이블에 값을 불연속적으로 넣어줬었는데, 여기서는 항상 누적 합이 되기 때문에 계속 값을 쌓아가면 된다. 그래서 일차적으로 DP 테이블을 어떻게 설계할 것인지가 다이나믹 프로그래밍 문제를 푸는 첫 번째 관건이다.

그렇지만 사실 DP 테이블 설계를 위해서는 이전에 어떤 점화식을 갖는 지를 파악해야 한다. 이전 문제에서는 이렇다할 점화식이 존재하지 않아 DP 테이블에 저장되는 값이 뒤죽박죽이었지만, 여기서는 누적합 컨셉으로 잡은 이상 대체로 점화식이 존재하게 되어 있다. 그 점화식은 문제를 열심히 분석해서 찾아내야 하는데, 이게 정말 어려웠다.

그렇게 찾은 점화식은 아래와 같다.

$a_{i} = max(a_{i-1} , a_{i-2} + k_{i})$

마주한 식량창고에서는 인접한 식량창고를 털 수 없다. 그렇기에 다음에 식량창고를 터는 최적의 경우의 수는 단 두 가지가 존재한다.

1. 이전에 창고를 털어 다음에는 창고를 털지 못함.
2. 그전에 창고를 털었고 다음에 창고를 또 털어버림.

이 외에는 최적의 경우의 수는 존재하지 않음. 그래서 둘 중 더 큰 누적 합을 만들어내는 선택지를 골라주면 된다.

여기서 의심을 할 수 있다. 만약에 i=2에서 털고 i=3에서 또 털어버리는 식의 연속으로 털어버리는 현상이 일어날 수 있지 않느냐고. 하지만 놀랍게도 위 점화식에서는 그런 일이 일어나지 않는다. 자.. 보라.

{ 1, 4, 6, 3, 5  }  << 현재 창고 상태

1. i = 1, 2인 경우(초기값) : 1보다 4가 크므로 d = [1, 4]
2. i = 3 : 4 < 1 + 6 이므로 d = [1, 4, 7]
    
    보이는가? 이전에 털었다는 것을 가정한 상태로 상태가 유지되는 경우와 이전에 털지 않고 다음에 털 것이라는 상태를 가정한 경우를 비교하는 모습을 볼 수 있다. 그래서 i = 2인 경우에는 당장 터는 쪽이 더 큰 기대값을 갖는 반면, i = 3인 경우에는 지금 털지 않는 쪽이 더 기대값이 크기 때문에 서로 정반대의 상황에 대해 DP 테이블에 최선의 값이 저장된 것을 볼 수 있다. **마치 여러 개의 멀티버스 중에서 가장 최선의 되는 경우에 대해 다음 값을 선정하는 것과 같다.** 그래서 이전 상태가 계속 유지되어야 하는 것이고, 다이나믹 프로그래밍을 구현한 것이다.
    
3. i = 4 : 7 = 4 + 3 이므로 d = [1, 4, 7, 7]
4. i = 5 : 7 < 6 + 5 이므로 d = [1, 4, 7, 7, 11]. 따라서 답은 11.

무슨 점화식이 근본없이 매번 여러 가지 멀티버스 중에서 최적의 수를 고르냐고 할 수 있지만, 틀을 깨야 한다. 따지고 보면 이전 상태로부터 다음 상태를 결정하는 것은 맞기 때문에 결국 점화식이 맞다. 그리고 이전 상태를 베이스로 하는 점화식이 형성된다는 것은 다이나믹 프로그래밍으로 구현하라는 뜻이고.