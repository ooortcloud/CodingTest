# 00. 설명

# 목차
- [00. 설명](#00-설명)
- [목차](#목차)
- [정렬 알고리즘](#정렬-알고리즘)
  - [선택 정렬](#선택-정렬)
    - [선택 정렬 소스코드](#선택-정렬-소스코드)
    - [선택 정렬의 시간 복잡도](#선택-정렬의-시간-복잡도)
  - [삽입 정렬](#삽입-정렬)
    - [삽입 정렬 소스 코드](#삽입-정렬-소스-코드)
    - [삽입 정렬의 시간 복잡도](#삽입-정렬의-시간-복잡도)
  - [퀵 정렬](#퀵-정렬)
    - [퀵 정렬 소스 코드](#퀵-정렬-소스-코드)
    - [퀵 정렬의 시간 복잡도](#퀵-정렬의-시간-복잡도)
  - [계수 정렬(Count Sort)](#계수-정렬count-sort)
    - [계수 정렬 소스 코드](#계수-정렬-소스-코드)
    - [계수 정렬의 시간 복잡도](#계수-정렬의-시간-복잡도)
  - [파이썬 정렬 라이브러리](#파이썬-정렬-라이브러리)
  - [어떤 정렬 기법을 선택해야 하는가?](#어떤-정렬-기법을-선택해야-하는가)


# 정렬 알고리즘

**`정렬`은 데이터를 특정한 기준에 따라서 순서대로 나열하는 것이다.** 오름차순 또는 내림차순으로 정렬하는 두 가지의 방법이 있다. 한쪽 방향에 대한 정렬 방식만 익힌다면, 각각의 케이스에 따라 정렬한 뒤 뒤집는 연산을 통해 나머지 정렬도 구현할 수 있다. 뒤집기 연산은 O(N) 정도의 시간 복잡도를 갖기 때문에 연산에 큰 지장을 주지는 않을 것이다. 그렇기에 우선 오름차순을 기준으로 정렬하는 여러 방법들에 대해 알아보자.

## 선택 정렬

**`선택 정렬` 알고리즘은 매번 가장 작은 것을 선택해서 데이터를 교환하는 정렬 알고리즘이다.** 가장 작은 것을 선택해서 앞으로 보내는 과정을 반복하다 보면 자연스럽게 전체 데이터 정렬이 이뤄질 것이다. 

### 선택 정렬 소스코드

```python
arr = [7,5,9,0,3,1,6,2,4,8]

for i in range(len(arr)):
	minIndex = i  # 가장 작은 원소의 인덱스 변수 지정 (초기값: 현재 탐색 시작 인덱스)
	
	for j in range(i+1, len(arr)):  # 항상 탐색 시작 다음 인덱스부터 조사
		if arr[minIndex] > arr[j]:  # 가장 작은 원소를 찾으면 해당 인덱스 지정
			minIndex = j

	arr[minIndex], arr[i] = arr[i], arr[minIndex]  # 가장 작은 원소와 현재 탐색 원소를 교환

print(arr)
```

### 선택 정렬의 시간 복잡도

총 연산 횟수는  $N + (N-1) + (N-2) + … + 2 = N(N+1)/2 = O(N^{2})$이다.

선택 정렬은 기본 정렬 라이브러리 및 다른 정렬 알고리즘과 비교했을 때 매우 비효율적인 알고리즘이다. 하지만 특정 리스트가 주어졌을 때 가장 작은 원소를 찾는 알고리즘이 코딩 테스트에서 많이 요구되기 때문에 구현할 줄은 알아야 한다.

## 삽입 정렬

**`삽입 정렬`은 데이터에서 적절한 위치를 찾은 후에 해당 위치에 삽입하는 알고리즘이다. “데이터가 거의 정렬되어 있을 때” 데이터 교환이 거의 일어나지 않는다는 장점이 있다.** 다만 구현 난이도가 조금 있는 편이다.

### 삽입 정렬 소스 코드

```python
arr = [7,4,5,3,8,6,9,2,1]

for i in range(1, len(arr)):
    for j in range(i, 0, -1):
        if arr[j] < arr[j-1]:
            arr[j-1], arr[j] = arr[j], arr[j-1]
        else:
            break
print(arr)
```

반드시 탐색하고자 하는 요소의 인덱스부터 내려가면서 탐색을 진행해야 한다. 그래야 현 위치에서부터 순차적으로 내려오면서 적절한 위치에 삽입해줄 수 있다. 반대로 첫 번째 인덱스부터 올라가면서 탐색을 진행하게 되면 내가 삽입해야 할 데이터를 저 끝에 가야 찾을 수 있으므로 제대로 정렬이 될 리가 없다.

### 삽입 정렬의 시간 복잡도

**현재 리스트가 거의 정렬되어 있는 상태라면 $O(N)$의 최선의 시간 복잡도를 보여준다.** 하지만 이외의 경우에는 선택 정렬처럼 $O(N^{2})$의 최악의 시간 복잡도를 보여준다. 그래서 일반적인 경우에 삽입 정렬은 비효율적인 정렬 알고리즘이지만 리스트가 거의 정렬되어 있는 경우에는 1티어 정렬 알고리즘이므로, 리스트의 정렬 정도를 파악한 뒤에 삽입 정렬을 활용하면 된다.

## 퀵 정렬

**`퀵 정렬`은 기준 데이터를 설정한 후, 해당 기준 데이터를 기준으로 작은 데이터는 왼쪽으로 큰 데이터는 오른쪽으로 몰아놓는 정렬 알고리즘이다.** 어떤 상황이든 일관성 있게 좋은 성능을 보장하기 때문에 가장 많이 사용되는 정렬 알고리즘이다.

퀵 정렬의 flow를 요약하면 아래와 같다.

1. 리스트에서 제일 앞의 데이터를 pivot으로 지정한다.
2. 두 번째 데이터부터 오른쪽으로 탐색하면서 pivot보다 큰 데이터를 찾고, 가장 끝 데이터부터 왼쪽으로 탐색하면서 pivot보다 작은 데이터를 찾는다.
3. 찾은 두 데이터를 서로 교환한다.
4. 만약 탐색 도중 두 번째 데이터부터 시작한 탐색 포인터와 가장 끝에서부터 시작한 탐색 포인터가 서로 교차되는 경우, 탐색을 종료하고 엇갈리기 직전 두 포인터가 가리키는 데이터 둘 중 작은 것과 pivot의 위치를 서로 교환한다.
5. 이렇게 되면 교환된 pivot의 위치를 기준으로 왼쪽은 pivot보다 작은 값, 오른쪽은 pivot보다 큰 값으로 분할된다. 이렇게 분할된 각 리스트에 대해서 1~4의 과정을 반복한다.

### 퀵 정렬 소스 코드

```python
arr = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quickSort(arr, start, end):
    # 리스트 길이가 1인 경우 재귀 종료
    if start >= end:
        return
    
    pivot = start
    left = start + 1
    right = end
    # left 포인터와 right 포인터가 서로 교차되면 종료
    while left <= right:
        # left 포인터가 리스트 끝에 도달하거나 pivot보다 큰 데이터를 찾을 때까지 탐색
        while left <= end and arr[left] <= arr[pivot]:
            left += 1
        
        # right 포인터가 리스트 앞에 도달하거나 pivot보다 작은 데이터를 찾을 때까지 탐색
        while start < right and arr[right] >= arr[pivot]:
            right -= 1

        # left 포인터와 right 포인터가 서료 교차되면 pivot과 작은 값을 가진 데이터를 서로 교환.
        # left는 항상 pivot보다 큰 값을 찾고, right는 항상 pivot보다 작은 값을 찾기 때문에 right가 가리키는 데이터가 항상 left가 가리키는 데이터보다 더 작은 것이 보장됨. + pivot보다도 작은 것이 보장됨.
        if left > right:
            arr[right], arr[pivot] = arr[pivot], arr[right]
        # 그 외의 경우에는 left 포인터와 right 포인터가 가리키는 값을 서로 교환
        else:
            arr[left], arr[right] = arr[right], arr[left]
    
    # 분할 이후 왼쪽과 오른쪽에 대해 다시 퀵 정렬 수행
    # 분할 직전 right가 가리키는 데이터와 pivot 데이터를 서로 교환하므로, 분할의 중심점은 right 포인터의 위치로 보장됨.
    quickSort(arr,start, right-1)
    quickSort(arr,right+1, end)

quickSort(arr, 0, len(arr)-1)
print(arr)
```

### 퀵 정렬의 시간 복잡도

**퀵 정렬의 평균 시간 복잡도는 $O(Nlog_2N)$이다. (통상 NlogN)** N과 NlogN의 차이는 데이터를 단순히 일렬로 쭉 늘어뜨린 것과, 데이터를 트리 구조로 레벨을 나눠서 나열한 것의 차이를 갖는다. 데이터가 N개인 경우, $O(N)$인 경우 일일이 하나씩 데이터를 뒤져보아야 하는 반면,  $O(Nlog_2N)$인 경우에는 먼저 $logN$개의  높이 순으로 검색한 후에 해당 높이에서 남은 데이터를 검색한다. 이 차이로 인해 데이터가 많을수록 검색 속도가 상대적으로 매우 빨라지는 것이다.

예컨데, N이 백만인 경우 선택 정렬은 백만의 제곱에 해당하는 연산 횟수를 갖는 반면, 퀵 정렬은 대략 2천만 회의 연산 횟수를 가져 엄청난 연산량의 차이를 보인다.

![Untitled](00%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC%201845d6cf83a4419a899fb053e97ba9cd/Untitled.png)

다만, 퀵 정렬도 최악의 경우에는 시간 복잡도가 $O(N^{2})$이다. (이미 데이터가 정렬되어 있는 경우) 그래서 보편적으로 데이터가 무작위로 들어가 있는 경우에 퀵 정렬이 좋다는 뜻이지, 퀵 정렬이 항상 절대 만능은 아니다. 대신 앞서 이미 데이터가 정렬되어 있는 경우 삽입 정렬의 시간 복잡도는 $O(N)$으로 최선의 값을 갖기 때문에, 퀵 정렬의 최악의 상황을 커버할 수 있다. 그래서 퀵 정렬과 삽입 정렬은 항상 세트로 생각해두어야 한다.

참고로 파이썬이 제공하는 기본 정렬 라이브러는 $O(NlogN)$을 보장하므로, 일반적으로 개발하는 상황에서는 퀵 정렬을 구현할 일은 없다. 다만 코딩 테스트를 하기 위해서는 반드시 알아야 할 덕목.

## 계수 정렬(Count Sort)

**`계수 정렬`은 최솟값과 최댓값 사이의 데이터 크기 범위가 좁고 각 데이터가 정수형으로 표현되어 있을 때, 매우 빠른 정렬을 보장하는 특이한 정렬 알고리즘이다.** 원리는 매우 간단하다. 리스트의 인덱스를 데이터로 활용해서 정렬하는 방식이다. 예컨데 주어진 데이터가 [2, 4, 0, 3] 와 같다면, 새로운 리스트를 만든 후에 각 데이터에 해당하는 인덱스에 count를 증가시킨다. 그리고 최종적으로 0번 인덱스부터 count 횟수만큼 순차 반복 출력하면 끝. 그래서 계수 정렬을 구현하려면 반드시 데이터가 정수형으로 표현되어 있어야 하며, 최솟값과 최댓값 사이의 데이터 크기 범위가 가능한 좁아야 한다. 대표적으로 0~100 점 사이의 정수형 데이터가 보장되는 시험 성적을 매기는 경우가 계수 정렬을 적용하기 적합한 상황이다.

### 계수 정렬 소스 코드

```python
arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 최솟값 0에서 최대값까지의 인덱스 범위를 갖는 리스트를 생성하여 0으로 초기화
cnt = [0] * (max(arr)+1)

# 각 데이터에 해당하는 인덱스의 값 1씩 카운트
for i in range(len(arr)):    
    cnt[arr[i]] += 1

# 카운터 리스트에서 순차적으로 값을 뽑아와서 그만큼 반복 출력
for i in range(len(cnt)):
    for j in range(cnt[i]):
        print(i, end = ' ')
```

### 계수 정렬의 시간 복잡도

모든 데이터가 양의 정수이며 데이터 개수가 N개, 가장 큰 데이터 값이 K라고 가정했을 때, 계수 정렬의 시간 복잡도는 $O(N+K)$이다. 앞서 언급한 조건들만 만족한다면, 현존하는 정렬 알고리즘 중에서 OP급 속도를 자랑한다.

다시 말하자면, 계수 정렬은 데이터의 크기가 한정되어 있고 많이 중복되어 있을수록 유리하다. 하지만 단 두 개의 데이터 1과 1백만이 존재하는 경우에 계수 정렬로 정렬하려고 한다면 최악의 성능을 보여주게 된다. 그래서 입력받을 데이터의 성격을 파악할 수 없는 경우에는 무난하게 퀵 정렬을 활용하면 된다.

## 파이썬 정렬 라이브러리

파이썬에서는 기본 정렬 라이브러리인 `sorted()` 함수를 제공한다. 이 함수는 병합 정렬과 삽입 정렬의 하이브리드 코드로 구성되어 있으며 항상 $O(NlogN)$의 시간 복잡도를 보장한다. 어떤 자료형을 입력받아도 항상 정렬된 리스트를 반환한다.

```python
arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

print(sorted(arr))  # [0, 0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 9]
```

리스트 객체 내장 함수 `sort()`를 사용해서 내부 원소를 바로 정렬할 수도 있다. 

```python
arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

arr.sort()
print(arr)
```

참고로 sorted와 sort 함수에 정렬 기준인 key 매개변수를 옵션으로 넣어줄 수 있다. 예컨데 리스트 내 요소를 튜플로 정의한 경우, 튜플의 특정 인덱스 위치에 저장된 값을 기준으로 정렬을 할 수 있다.

```python
arr = [('a', 3), ('c', 1), ('b', 5)]

def setting(data):
    return data[1]

print(sorted(arr, key=setting))  # [('c', 1), ('a', 3), ('b', 5)]
```

람다 함수를 활용하여 응용할 수도 있는데, 자세한 내용은 부록에서 확인해보자. (우린 이미 배운 적이 있다.)

## 어떤 정렬 기법을 선택해야 하는가?

1. 정렬 라이브러리로 풀 수 있는 문제
    
    파이썬에서 제공하는 정렬 라이브러리를 활용한다. 개발 시간도 단축되며, 성능도 보장된다.
    
2. 정렬 알고리즘 구현을 요구하는 문제
    1. 삽입 정렬 - 데이터 대부분이 이미 정렬되어 있는 경우
    2. 선택 정렬 - 데이터 개수가 충분히 작으며, 구현을 급히 해야 하는 경우
    3. 퀵 정렬 - 그 외의 대부분의 경우
3. 더 빠른 정렬이 필요한 문제
    1. 계수 정렬 - 데이터가 정수형이며, 최솟값과 최댓값의 범위 차이가 좁은 경우
    2. 문제에서 제공된 알고리즘을 구조적으로 개선한다.