# 03. 두 배열의 원소 교체

## 문제 정보

동빈이는 두 개의 배열 A와 B를 갖고 있다. 두 배열은 N개의 원소로 이뤄져 있으며, 배열의 원소는 모두 자연수이다. 동빈이는 최대 K번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 요소 하나와 배열 B에 있는 요소 하나를 서로 바뀌치는 것을 말한다. 동빈이의 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이다.

N, K, 그리고 배열 A, B의 정보가 주어졌을 때 최대 K번의 바꿔치기 연산을 하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하자.

예를 들어, N=5, K=3이고 배열은 다음과 같다고 하자.

A = [1, 2, 5, 4, 3]

B= [5, 5, 6, 6, 5]

이 경우 배열 A의 원소 1, 2, 3을 배열 B의 원소 6, 6, 5로 순차적으로 바꿔치기 연산을 하면 A의 모든 요소의 합의 최댓값인 26을 구할 수 있다.

### 문제 요약

N, K, 그리고 배열 A, B의 정보가 주어졌을 때 최대 K번의 바꿔치기 연산을 하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하자.

### 입력

- 첫 번째 줄에 N, K가 공백으로 구분되어 주어진다. (N은 1 이상 100,000 이하, K는 0 이상 N 이하)
- 두 번째 줄에 배열 A의 원소들이 공백으로 구분되어 입력된다. 모든 원소는 10,000,000보다 작다.
- 세 번째 줄에 배열 B의 원소들이 공백으로 구분되어 입력된다. 모든 원소는 10,000,000보다 작다.

### 출력

- 최대 K번의 바꿔치기 연산을 통해 만들 수 있는 배열 A의 모든 원소 합의 최댓값을 출력한다.

### 예제 입력 1

```python
5 3
1 2 5 4 3
5 5 6 6 5
```

### 예제 출력 1

```python
26
```

## 문제의 의도

- 위 문제의 해결책을 구현할 수 있는가?

### 아이디어

- 배열 A를 오름차순, 배열 B를 내림차순으로 정렬한 뒤, K번만큼 순차적으로 값 교환을 해주면 된다.

### 풀이

- 내 풀이 (오답)

```python
n, k = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

b.sort(reverse=True)
a.sort()

for i in range(k):
    a[i], b[i] = b[i], a[i]

print(sum(a))
```

만약 a 리스트의 최소값이 b리스트의 최대값보다 큰 경우, 이 풀이는 오답이다. 그러므로 조건을 추가하여 예외를 처리해야 한다.

- 답안 풀이

```python
n, k = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

b.sort(reverse=True)
a.sort()

for i in range(k):
    if a[i] < b[i]:
        a[i], b[i] = b[i], a[i]
    else:
        break

print(sum(a))
```

a의 작은 원소가 b의 큰 원소보다 작은 경우인 동안만 바꿔치기 연산을 수행하도록 한다. 만약 특정 지점부터 a의 작은 원소가 b의 큰 원소의 크기보다 큰 경우에는 더 이상의 의미가 없으므로 바뀌치기 연산을 종료한다.