# 24416_py

# 24416: **알고리즘 수업 - 피보나치 수 1**

## 문제 정보

오늘도 서준이는 동적 프로그래밍 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

오늘은 *n*의 피보나치 수를 재귀호출과 동적 프로그래밍으로 구하는 알고리즘을 배웠다. 재귀호출에 비해 동적 프로그래밍이 얼마나 빠른지 확인해 보자. 아래 의사 코드를 이용하여 *n*의 피보나치 수를 구할 경우 코드1 코드2 실행 횟수를 출력하자.

피보나치 수 재귀호출 의사 코드는 다음과 같다.

```cpp
fib(n) {
    if (n = 1 or n = 2)
    then return 1;  # 코드1
    else return (fib(n - 1) + fib(n - 2));
}
```

피보나치 수 동적 프로그래밍 의사 코드는 다음과 같다.

```cpp
fibonacci(n) {
    f[1] <- f[2] <- 1;
    for i <- 3 to n
        f[i] <- f[i - 1] + f[i - 2];  # 코드2
    return f[n];
}
```

### 문제 요약

주어진 의사 코드를 이용하여 *n*의 피보나치 수를 구할 경우 코드1 코드2 실행 횟수를 출력하자.

### 입력

- 첫째 줄에 *n*(5 ≤ *n* ≤ 40)이 주어진다.

### 출력

- 코드1 코드2 실행 횟수를 한 줄에 출력한다.

### 예제 입력 1

```c
5
```

### 예제 출력 1

```c
5 3
```

### 예제 입력 2

```c
30
```

### 예제 출력 2

```c
832040 28
```

## 문제의 의도

- 주어진 함수를 파이썬 언어로 변환하여 구현할 수 있는가?

### 아이디어

- 뭔가 C++ 문법(배열)으로 보인다… 대략 느낌적인 느낌으로 리스트 자료구조를 활용하여 구현해보자.

### 풀이

- 내 풀이

```python
def fib(n):
    global count1
    if (n==1 or n==2):
        count1 += 1
        return 1  # 코드 1
    else:
        return (fib(n-1) + fib(n-2))
    
def fibonacci(n):
    global count2
    for i in range(2, n):
        count2 += 1
        f[i] = f[i-1] + f[i-2]  # 코드 2
    return f[i]

n = int(input())

f = list()
for _ in range(n):
    f.append(0)  # 함수 안에 append를 넣어버리면 재귀하면서 필요 이상으로 리스트를 생성해버림. -> 시간초과

count1, count2 = 0, 0
fib(n)
fibonacci(n)
print(count1, count2)
```

제출할 때는 PyPy3로 제출했다. 여기서 f[0]과 f[1]을 초기화를 시켜주지 않아서 연산 결과는 잘못되어 있겠지만, 답안에 내야 할 결과는 카운트 값이므로 오답이 아니라 정답 처리되었다. 물론 정답까지 맞추려면 추가적으로 함수 호출 전에 f[0]과 f[1]을 1로 초기화하고 들어가야 할 것이다.

- 다른 풀이

```python
f = [None]*50
f[1] = f[2] = 1

n = int(input())

def fibonacci(n):
    for i in range(3, n+1):
        f[i] = f[i-1]+f[i-2]
    return f[n]

count1 = fibonacci(n)
count2 = n-2
print(k1, k2)
```

사실 수학적 계산 결과를 요구하는 것이 아닌 피보나치 수를 구하는 경우 함수의 호출 횟수만 구하면 되기 때문에, 코드 내용을 “피보나치 내부에서 카운트를 구하는 코드”로 변형시켜도 무방하다. 답만 맞으면 되는 거니까.

1. 코드 1의 경우에는 “재귀 호출”로 만들어진 함수이다. **만약 피보나치 수열을 재귀 형태로 만드는 경우, 결론부터 말하자면 해당 함수가 1을 반환하는 횟수는 피보나치 수열의 결과값과 동일하다.**
    1. 예를 들어보자. n=1인 경우 함수 호출 횟수는 1회. n=2인 경우에도 함수 호출 횟수는 1회다. (조건문에 의해 바로 리턴) 이 값은 피보나치 함수에서 리턴한 값과 같다.
    2. n≥3이면 어떨까? n=3인 경우 f(2)과 f(1)를 호출하며 2번의 1을 반환하고 끝이 난다. 이는 f(3)의 리턴값인 1+1=2와 같다. n=4인 경우, f(3)과 f(2)를 호출하게 되는데, f(3)은 2번 1을 반환하며, f(2)는 1번 1을 반환하므로 총 3번 1을 반환하게 된다. 이는 f(4)의 리턴값인 2+1 = 3과 같다… 같은 방식으로 생각해보았을 때, 이 함수가 1을 반환하는 횟수는 피보나치 수열의 결과값과 동일할 것이다. (수학적 귀납법 추론 방법이다.)
    
    참고로 위 코드에서는 동적 계획법 함수로 재귀 호출을 카운트하고 있는데, 어차피 f 리스트에 저장될 값들은 동일하며 출력해야 할 값은 해당 리스트의 가장 끝 값이기 때문에 보다 더 효율적인 동적 계획법 코드로 구사해도 상관없다.
    
2. 코드 2는 “동적 계획법(Dynamic Programming)”으로 만들어진 함수이다. 재귀 함수에서는 자기 자신을 계속 호출해서 반복하는 형태를 구현했지만, 비효율적인 연산을 보여준다. 반면 동적 계획법으로 만든 코드에서는 그냥 함수에 반복문을 넣어서 직접적으로 반복을 구현하여, 앞의 연산을 더 이상 반복하지 않음으로써 효율적인 코드를 구현할 수 있다. 이미 우리는 수학적으로 어떤 성질을 띄는지 알고 있으니, 굳이 일일이 재귀하면서 값을 더해나갈 필요가 없다는 것을 아니까 수학적으로 축약해서 동적 계획법이 가능한 것이다. 그리고 그 안에서 피보나치 연산이 반복되는 횟수를 구하는 것이 목표였으니, 두 번째 답은 n-2. (2부터 n-1까지 반복하므로 총 반복 횟수는 (n-1-2)+1=n-2번)

### 참고 자료

[https://freshmath.tistory.com/6](https://freshmath.tistory.com/6)