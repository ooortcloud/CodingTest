# 1541_py

# 1541: 잃어버린 괄호

## 문제 정보

세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.

그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.

괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.

### 입력

- 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.

### 출력

- 첫째 줄에 정답을 출력한다.

### 예제 입력 1

```python
55-50+40
```

### 예제 출력 1

```python
-35
```

### 예제 입력 2

```python
10+20+30+40
```

### 예제 출력 2

```python
100
```

### 예제 입력 3

```python
00009-00009
```

### 예제 출력 3

```python
0
```

## 문제의 의도

- 서로 다른 기준을 갖는 문자열을 구분하는 방식을 구현할 수 있는가?

### 아이디어

- 먼저 합 연산을 우선적으로 한다. 그리고 나머지 차 연산을 한 번에 진행하면 어떤 상황이든 가장 최소값을 구할 수 있다.

### 풀이

- 내 풀이 (출력 초과)

```python
import re

s = input()
numbers = re.findall(r'\d+', s)
numbers = [int(x) for x in numbers]  # list(map(int, numbers)) 로도 "문자 -> 숫자" 변환 가능. 하지만 리스트 컴프리헨션이 더 깔끔해.
operators = re.findall(r'[+-]', s)

minusList = list()
indexNum = 0
# 합 연산 우선 -> 그래야 수학적으로 더 큰 값이 뒤에 있어서 더 크게 뺄 수 있음.
while operators:
    operator = operators.pop(0)
    if operator == '+':
        numbers[indexNum] = numbers[indexNum] + numbers.pop(indexNum+1)      
        continue
    else:
        minusList.append('-')
        indexNum += 1

# 나머지 차 연산 순차적으로 진행
for _ in minusList:
    numbers[0] -= numbers.pop(1)
    
print(numbers[0])
```

정규 표현식(Regular Expression, re)은 문자열의 패턴을 표현하는 강력한 도구로, 특정 규칙을 가진 문자열을 검색, 추출 또는 대체하는 작업에 사용된다. 파이썬의 're' 모듈은 정규 표현식을 다루기 위한 기능을 제공한다. 온라인 상에 관련 메소드 및 문법 자료가 있으니 찾아보시길.

이 코드는 예제에 있는 모든 경우에 대해서 정답을 반환했다. 하지만 백준 컴파일러 상에서 돌렸을 때 자꾸 출력 초과가 뜬다. 로그 print 함수들을 다 제거했음에도 뜬다는 건 “틀렸습니다!” 일 가능성이 높다…

- 다른 이의 풀이

```python
exp = input().split('-')  # '-'를 기준으로 split해서 리스트에 저장

num = []  # '-'로 나눈 항들의 합을 저장할 리스트

for i in exp:
    sum = 0
    tmp = i.split('+')  # 앞서 split한 원소들에 대해 덧셈을 하기 위해서 '+'를 기준으로 다시 split
    for j in tmp:  # split한 리스트의 각 요소들을 더해줌
        sum += int(j)
    num.append(sum)  # 각 항의 연산 결과(덧셈)를 저장

n = num[0]
for i in range(1,len(num)):  # 1번째 값부터 n까지 차례로 빼준다
    n -= num[i]
print(n)
```

핵심 알고리즘은 나와 동일하다. 하지만 구현 방식에서 큰 차이가 있다. 나는 re 모듈을 import하여 숫자 / 연산자를 각각 리스트로 받아서 처리를 했는데, 이 분은 **String의 split 메소드를 두 번 사용하여 각각 ‘-’일 때와 ‘+’일 때를 구분하여 리스트에 담아서 처리를 했다.**  내가 합 연산을 우선적으로 처리하고 나머지 차 연산을 한 번에 처리하기 위해 로직을 구현했던 것처럼, 먼저 크게 ‘-’에 대해 split을 한 후 이어서 ‘+’에 대해 split을 함으로써 동일한 목적에 맞게 구현할 수가 있었다. 

이 구현 방식은 re 모듈에 의존하지 않으며, 코드도 짧기 때문에 더 좋은 코드라고 생각한다. 그리고 **이 방식이 정말 좋은 이유는, 리스트의 `pop(0)`을 사용하지 않는다는 거다.** 리스트에서 pop(0) 연산은 O(n)의 시간복잡도를 갖기 때문에 가급적이면 사용해서는 안된다. 하지만 나는 이를 남발했고, 그래서 출력 초과가 떴을 가능성을 보고 있다. 리스트 대신 "deque의 popleft()"를 사용하는 것이 pop(0)의 대안이 될 수 있지만, deque는 양끝 pop만 지원하기 때문에 내 구현 방식으로는 deque를 써도 소용없다. 그래서 리스트의 중간 인덱스에 대해 pop연산을 하는 구현을 하는 것은 반드시 금지해야 한다. (양끝 pop은 deque를 쓰면 되니까 오히려 좋을지도.)

### 참고 자료

[https://sodehdt-ldkt.tistory.com/49](https://sodehdt-ldkt.tistory.com/49)