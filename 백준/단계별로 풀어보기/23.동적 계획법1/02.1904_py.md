# 1904_py

# 1904: 01타일

## 문제 정보

지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.

어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.

그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.

우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.

### 문제 요약

우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다.

### 입력

- 첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)

### 출력

- 첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.

### 예제 입력 1

```python
4
```

### 예제 출력 1

```python
5
```

## 문제의 의도

- 주어진 문제를 해결하기 위해 코드를 구현할 수 있는가?

### 아이디어

- set 자료구조로 “00”과 “1”의 사용 개수를 경우마다 저장한 뒤, 각 경우마다 가능한 전체 경우의 수를 구한다. (문자열의 길이가 n이 되는 경우마다 카운트하면서 리셋) 최종적으로 set의 길이를 출력하면 될 것이다.

### 풀이

몇 중 반복문을 구현해야 하는지… 괜찮은 풀이가 생각나지 않는다. 

- 다른 사람 풀이

```python
N = int(input())

dp = [0] * 1000001  # 반복문에서 append를 넣어두면 불필요하게 리스트 길이가 늘어날 수 있음. 그러므로 미리 리스트 길이를 정해두고 시작. (maximum이 주어져 있으니까)
dp[1], dp[2] = 1, 2
for i in range(3,N+1):
    dp[i] = (dp[i-1] + dp[i-2]) % 15746

print(dp[N])
```

일일이 경우의 수를 구해서 답을 도출해내는 방식을 구상하기 전에, 먼저 수학적으로 일반화할 수는 없는 지를 파악해야 한다. 특히 피보나치 수열과 같이, 특정 구간부터 앞의 값에 특정 규칙을 적용하면 뒤의 값이 나오는 그런 형태를 갖고 있는 지를 곰곰이 생각해봐야 한다.
이 문제 역시 앞의 형태를 바탕으로 규칙성을 갖는다.

- n=1 : [1] → 1개
- n=2 : [00], [11] → 2개
- n=3 : [001], [100], [111] = [00]([1]), [1]([00], [11]) = “n=1인 경우” + “n=2인 경우” → 3개
- n=4 : [0000], [0011], [1001], [1100], [1111] = [00]([00], [11]), [1]([00]([1]), [1]([00], [11])) = “n=2인 경우” + “n=3인 경우” → 5개
- 따라서, n=k일 때 : “n=k-2인 경우의 수” + “n=k-1인 경우의 수” 가 된다. (단, n=1일 때 1, n=2일 때 2)

### 참고 자료

[https://chancoding.tistory.com/23](https://chancoding.tistory.com/23)